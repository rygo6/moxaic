#version 450
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_debug_printf : require

#define LOCAL_SIZE 4
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform State {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} state;
layout (set = 0, binding = 1, r16) uniform image2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer[];


float Lerp(float a, float b, float t) {
    return a + ((b - a) * t);
}

float LinearizeDepth(float zNear, float zFar, float projectionDepth) {
    return zNear * zFar / (zFar - projectionDepth * (zFar - zNear));
}

float ProjectDepth(float newNear, float newFar, float linearDepth) {
    return (newFar * (linearDepth - newNear)) / (linearDepth * (newFar - newNear));
}

uint SubgroupOffsetIndex(ivec2 dxdy) {
   return gl_SubgroupInvocationID + dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

uint SubgroupIndex(ivec2 dxdy) {
    dxdy %= ivec2(gl_WorkGroupSize.xy);
    return dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

float AverageQuad(float value, int dxdy){
    float depths[4];
    depths[0] = value;
    depths[1] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, 0)));
    depths[2] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(0, dxdy)));
    depths[3] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, dxdy)));

    float count = 0.0f;
    for (int i = 0; i < 4; ++i) count += depths[i] > 0.0f ? 1.0f : 0.0f;
    int iCount = int(count);

    float depthSum = 0.0f;
    for (int i = 0; i < 4; ++i) depthSum += depths[i];
    float averageDepth = iCount > 0 ? depthSum / count : 0.0f;

    return averageDepth;
}

void main()
{
    ivec2 srcSize0 = imageSize(srcDepth);
    ivec2 dstSize0 = imageSize(dstGbuffer[0]);
    ivec2 coord0 = ivec2(gl_GlobalInvocationID.xy); // 8 x 8

    vec2 uv = vec2(coord0) / dstSize0;

    float depth = imageLoad(srcDepth, coord0).r;
    float linearDepth = LinearizeDepth(state.depth.nearZ, state.depth.farZ, depth);

    // reverse near/far because we use reverseZ
    float depth0 = ProjectDepth(state.cameraFarZ, state.cameraNearZ, linearDepth);

//    imageStore(dstGbuffer[0], coord0, vec4(globalDepth));

    ivec2 coord1 = coord0 / 2; // 4 x 4
    ivec2 coord1Sample = coord1 * 2;
    float depth1;
    ivec2 coord2 = coord0 / 4; // 2 x 2
    ivec2 coord2Sample = coord2 * 4;
    float depth2;
//    ivec2 coord3 = coord0 / 8; // 1 x 1
//    ivec2 coord3Sample = coord3 * 8; // 1 x 1
//    float depth3;
//    if ((coord0.x & 1) == 0 && (coord0.y & 1) == 0) {
//        depth1 = AverageQuad(depth0, 1);
////        imageStore(dstGbuffer[1], coord1, vec4(result1));
//        if ((coord1.x & 1) == 0 && (coord1.y & 1) == 0) {
//            depth2 = AverageQuad(depth1, 3);
////            imageStore(dstGbuffer[2], coord2, vec4(result2));
//            if ((coord2.x & 1) == 0 && (coord2.y & 1) == 0) {
//                depth3 = AverageQuad(depth2, 7);
////                imageStore(dstGbuffer[3], coord3, vec4(depth3));
//            }
//        }
//    }

    if ((coord0.x & 1) == 0 && (coord0.y & 1) == 0) {
        depth1 = AverageQuad(depth0, 1);
        if ((coord1.x & 1) == 0 && (coord1.y & 1) == 0) {
            depth2 = AverageQuad(depth1, 3);
        }
    }

//    if ((coord2.x & 1) == 0 && (coord2.y & 1) == 0) {
//        depth3 = AverageQuad(depth2, 7);
//    }
//    barrier();

//    if (gl_WorkGroupID.x == 32 && gl_WorkGroupID.y == 32) {
//        debugPrintfEXT("%d %d %d %d %d %d\n", coord0.x, coord0.y, coord2.x, coord2.y, coord2Sample.x, coord2Sample.y);
//    }

    depth1 = subgroupShuffle(depth1, SubgroupIndex(coord1Sample));
    depth2 = subgroupShuffle(depth2, SubgroupIndex(coord2Sample));
//    depth2 = subgroupShuffle(depth2, SubgroupIndex(ivec2(0,0)));
//    depth3 = subgroupShuffle(depth3, SubgroupIndex(coord3Sample));

//    depth1 = subgroupShuffle(depth2, 0);
//    depth2 = subgroupShuffle(depth2, 0);
//    depth3 = subgroupShuffle(depth3, 0);

//    if ((coord0.x & 1) != 0 && (coord0.y & 1) != 0) {
//        subgroupShuffle(depth1, SubgroupIndex(coord1Sample));
//    }
//
//    if ((coord1.x & 3) != 0 && (coord1.y & 3) != 0) {
//        subgroupShuffle(depth2, SubgroupIndex(coord2Sample));
//    }
//
//    if ((coord2.x & 7) != 0 && (coord2.y & 7) != 0) {
//        subgroupShuffle(depth3, SubgroupIndex(coord3Sample));
//    }

    float finalDepth = depth0 > 0 ? depth0 : depth1 > 0 ? depth1 : depth2;

    imageStore(dstGbuffer[0], coord0, vec4(finalDepth));

//    float depths[4];
//    depths[0] = linearDepth;
////    depths[1] = subgroupQuadSwapHorizontal(linearDepth);
//    depths[1] = subgroupShuffle(linearDepth, SubgroupIndex(1, 0));
////    depths[2] = subgroupQuadSwapVertical(linearDepth);
//    depths[2] = subgroupShuffle(linearDepth, SubgroupIndex(0, 1));
////    depths[3] = subgroupQuadSwapDiagonal(linearDepth);
//    depths[3] = subgroupShuffle(linearDepth, SubgroupIndex(1, 1));
//
//    if ((coord0.x & 1) == 0 && (coord0.y & 1) == 0) {
//
//        ivec2 coord1 = coord0 / 2;
//
//        float count = 0.0f;
//        for (int i = 0; i < 4; ++i) count += depths[i] > 0.0f ? 1.0f : 0.0f;
//        int iCount = int(count);
//
//        float depthSum = 0.0f;
//        for (int i = 0; i < 4; ++i) depthSum += depths[i];
//        float averageDepth = iCount > 0 ? depthSum / count : 0.0f;
//
////        imageStore(dstGbuffer[1], coord1, vec4(globalDepth));
//
////        memoryBarrierImage();  // Makes image writes visible
//        barrier();             // Synchronizes all threads in workgroup
//
//
//    }


}