#version 450
#extension GL_KHR_shader_subgroup_basic  : require
#extension GL_KHR_shader_subgroup_shuffle : require
//#extension GL_EXT_debug_printf : require

#include "math.glsl"
#include "subgroup_grid.glsl"

layout (local_size_x = SUBGROUP_CAPACITY, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform State {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} state;
layout (set = 0, binding = 1) uniform sampler2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer[];

shared float depths3[WORKGROUP_SUBGROUP_COUNT]; // 64
shared float depths4[WORKGROUP_SUBGROUP_COUNT / (2 * 2)]; // 4 * 4 = 16
shared float depths5[WORKGROUP_SUBGROUP_COUNT / (4 * 4)]; // 2 * 2 = 4
shared float depth6; // 1

float AverageNonZeroQuad(vec4 quad){
    int count = 0;
    float sum = 0.0f;
    for (int i = 0; i < 4; ++i) {
        count += int(quad[i] > HALF_EPSILON);
        sum += quad[i];
    }
    return count > 0 ? sum / float(count) : 0;
}

void main()
{
    ivec2 outputSize = imageSize(dstGbuffer[0]);
    InitializeSubgroupGridQuadInfo(outputSize);

    vec2 quadCenterUV = vec2(grid_GlobalCoord + 1) / vec2(outputSize);
    vec4 gatheredDepth = textureGather(srcDepth, quadCenterUV, 0);
//    {   // The only reason this is important is for linear sampling the depth. If I don't linear sample the depth this is probably pointless
//        // But linear sampling depth might produce better results? Need to A/B test. However if I don't linearly sample then I can use imageLoad on
//        // the gbuffer in compute composite which which might be faster
//        const int expand = 31;
//        const ivec2 expandGatherOffsets[4] = { { -expand, expand }, { expand, expand }, { expand, -expand }, { -expand, -expand }, };
//        // its possible use subgroup operations is faster than this
//        vec4 expandGatheredDepth = textureGatherOffsets(srcDepth, quadCenterUV, expandGatherOffsets, 0);
//        for (int i = 0; i < 4; ++i) {
//            gatheredDepth[i] = gatheredDepth[i] > HALF_EPSILON ? gatheredDepth[i] : expandGatheredDepth[i];
//        }
//    }

    vec4 gatheredLinearDepth = LinearizeDepth(vec4(state.depth.nearZ), vec4(state.depth.farZ), gatheredDepth);
    vec4 gatheredProjectedDepth = ProjectDepth(vec4(state.cameraFarZ), vec4(state.cameraNearZ), gatheredLinearDepth); // reverse near/far because we use reverseZ

    vec4 depth0Quad = gatheredProjectedDepth;
    float depth1 = AverageNonZeroQuad(gatheredProjectedDepth);
    float depth2 = 0;
    float depth3 = 0;
    float depth4 = 0;
    float depth5 = 0;
    float depth6 = 0;

    {
        // Subgroup averaging
        vec4 depth1Shuffle = vec4(
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(0, 1))),
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(1, 1))),
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(1, 0))),
            depth1);

        ivec2 depth2RootSubgroupCoord = ivec2(grid_SubgroupCoord / 2) * 2;
        uint depth2RootSubgroupIndex = SubgroupIndexFromCoord(depth2RootSubgroupCoord);
        if (depth2RootSubgroupCoord == grid_SubgroupCoord) {
            depth2 = AverageNonZeroQuad(depth1Shuffle);
            }
        subgroupBarrier();

        depth2 = subgroupShuffle(depth2, depth2RootSubgroupIndex);

        vec4 depth2Shuffle = vec4(
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(0, 2))),
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(2, 2))),
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(2, 0))),
            depth2);

        ivec2 depth3RootSubgroupCoord = ivec2(grid_SubgroupCoord / 4) * 4;
        uint depth3RootSubgroupIndex = SubgroupIndexFromCoord(depth3RootSubgroupCoord);
        if (depth3RootSubgroupCoord == grid_SubgroupCoord){
            depth3 = AverageNonZeroQuad(depth2Shuffle);
            depths3[grid_LocalSubgroupIndex] = depth3;
        }
        subgroupBarrier();

        depth3 = subgroupShuffle(depth3, depth3RootSubgroupIndex);

        barrier();
    }

    { // Workgroup averaging
        const int coordDivisor = 2;
        const int offset = coordDivisor / 2;
        ivec2 depth4SharedId = ivec2(grid_LocalSubgroupID / coordDivisor);
        uint depth4SharedIndex = IndexFromID(depth4SharedId, WORKGROUP_SQUARE_SIZE / coordDivisor);
        ivec2 depth4RootLocalCoord = depth4SharedId * coordDivisor;
        uint depth4RootLocalIndex = LocalSubgroupIndexFromCoord(depth4RootLocalCoord);
        if (grid_SubgroupIndex == 0 && grid_LocalSubgroupIndex == depth4RootLocalIndex) {
            vec4 depth3Shuffle = vec4(
                depths3[LocalSubgroupIndexFromOffset(ivec2(0, offset))],
                depths3[LocalSubgroupIndexFromOffset(ivec2(offset, offset))],
                depths3[LocalSubgroupIndexFromOffset(ivec2(offset, 0))],
                depth3);
            depths4[depth4SharedIndex] = AverageNonZeroQuad(depth3Shuffle);
        }

        barrier();
        depth4 = depths4[depth4SharedIndex];
    }

    {
        const int coordDivisor = 4;
        const int offset = coordDivisor / 2;
        ivec2 depth5SharedId = ivec2(grid_LocalSubgroupID / coordDivisor);
        uint depth5SharedIndex = IndexFromID(depth5SharedId, WORKGROUP_SQUARE_SIZE / coordDivisor);
        ivec2 depth5RootLocalCoord = depth5SharedId * coordDivisor;
        uint depth5RootLocalIndex = LocalSubgroupIndexFromCoord(depth5RootLocalCoord);
        if (grid_SubgroupIndex == 0 && grid_LocalSubgroupIndex == depth5RootLocalIndex) {
            vec4 depth4Shuffle = vec4(
                depths4[LocalSubgroupIndexFromOffset(ivec2(0, offset))],
                depths4[LocalSubgroupIndexFromOffset(ivec2(offset, offset))],
                depths4[LocalSubgroupIndexFromOffset(ivec2(offset, 0))],
                depth4);
            depths5[depth5SharedIndex] = AverageNonZeroQuad(depth4Shuffle);
        }

        barrier();
        depth5 = depths5[depth5SharedIndex];
    }

    // could do depth6 but think this will ultimately end up as 32x32 blocks and depths will be in one texture

//    if (gl_LocalInvocationIndex == 0) {
//        float minDepth = 1.0;
//        for (int i = 0; i < WORKGROUP_SUBGROUP_COUNT; i++)
//            minDepth = depths3[i] > HALF_EPSILON ? min(minDepth, depths3[i]) : minDepth;
//
//        depth6 = minDepth < 1.0 ?  minDepth : 0;
//    }

//    barrier();

    for (int i = 0; i < 4; ++i) {
        float finalDepth = depth0Quad[i] > 0 ? depth0Quad[i] :
            depth1 > 0 ? depth1 :
            depth2 > 0 ? depth2 :
            depth3 > 0 ? depth3 :
            depth4 > 0 ? depth4 :
            depth5;
        imageStore(dstGbuffer[0], grid_GlobalCoord + quadGatherOffsets[i], vec4(finalDepth));
    }
}