#version 450
#extension GL_KHR_shader_subgroup_basic  : require
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_debug_printf : require

#define LOCAL_SIZE 4
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform State {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} state;
layout (set = 0, binding = 1, r16) uniform image2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer[];


float Lerp(float a, float b, float t) {
    return a + ((b - a) * t);
}

float LinearizeDepth(float zNear, float zFar, float projectionDepth) {
    return zNear * zFar / (zFar - projectionDepth * (zFar - zNear));
}

float ProjectDepth(float newNear, float newFar, float linearDepth) {
    return (newFar * (linearDepth - newNear)) / (linearDepth * (newFar - newNear));
}

uint SubgroupOffsetIndex(ivec2 dxdy) {
   return gl_SubgroupInvocationID + dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

uint SubgroupIndex(ivec2 dxdy) { ;
    return dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

float MaxQuad(float value, int dxdy){
    float depths[3];
    depths[0] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, 0)));
    depths[1] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(0,      dxdy)));
    depths[2] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, dxdy)));
    for (int i = 0; i < 3; ++i)
        value = max(value, depths[i]);

    return 0;
}

float AverageQuad(float value, int dxdy){
    float depths[4];
    depths[0] = value;
    depths[1] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, 0)));
    depths[2] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(0, dxdy)));
    depths[3] = subgroupShuffle(value, SubgroupOffsetIndex(ivec2(dxdy, dxdy)));

    float count = 0.0f;
    float depthSum = 0.0f;
    for (int i = 0; i < 4; ++i) {
        count += depths[i] > 0.0f ? 1.0f : 0.0f;
        depthSum += depths[i];
    }
    return int(count) > 0 ? depthSum / count : 0;
}

void main()
{
    ivec2 srcSize0 = imageSize(srcDepth);
    ivec2 dstSize0 = imageSize(dstGbuffer[0]);
    ivec2 coord0 = ivec2(gl_GlobalInvocationID.xy); // 8 x 8

    float depth = imageLoad(srcDepth, coord0).r;
    float linearDepth = LinearizeDepth(state.depth.nearZ, state.depth.farZ, depth);
    // reverse near/far because we use reverseZ
    float depth0 = ProjectDepth(state.cameraFarZ, state.cameraNearZ, linearDepth);

    ivec2 coord1 = coord0 / 2; // 4 x 4
    ivec2 coord2 = coord0 / 4; // 2 x 2
    float depth1 = 0;
    float depth2 = 0;

    depth1 = AverageQuad(depth0, 1);
    depth2 = AverageQuad(depth1, 2);

    ivec2 coord1Sample = ivec2(gl_LocalInvocationID.xy / 2) * 2;
    ivec2 coord2Sample = ivec2(gl_LocalInvocationID.xy / 4) * 4;
    depth1 = subgroupShuffle(depth1, SubgroupIndex(coord1Sample));
    depth2 = subgroupShuffle(depth2, SubgroupIndex(coord2Sample));
    float finalDepth = depth0 > 0 ? depth0 : depth1 > 0 ? depth1 : depth2;

    imageStore(dstGbuffer[0], coord0, vec4(finalDepth));

//    float depths[4];
//    depths[0] = linearDepth;
////    depths[1] = subgroupQuadSwapHorizontal(linearDepth);
//    depths[1] = subgroupShuffle(linearDepth, SubgroupIndex(1, 0));
////    depths[2] = subgroupQuadSwapVertical(linearDepth);
//    depths[2] = subgroupShuffle(linearDepth, SubgroupIndex(0, 1));
////    depths[3] = subgroupQuadSwapDiagonal(linearDepth);
//    depths[3] = subgroupShuffle(linearDepth, SubgroupIndex(1, 1));
//
//    if ((coord0.x & 1) == 0 && (coord0.y & 1) == 0) {
//
//        ivec2 coord1 = coord0 / 2;
//
//        float count = 0.0f;
//        for (int i = 0; i < 4; ++i) count += depths[i] > 0.0f ? 1.0f : 0.0f;
//        int iCount = int(count);
//
//        float depthSum = 0.0f;
//        for (int i = 0; i < 4; ++i) depthSum += depths[i];
//        float averageDepth = iCount > 0 ? depthSum / count : 0.0f;
//
////        imageStore(dstGbuffer[1], coord1, vec4(globalDepth));
//
////        memoryBarrierImage();  // Makes image writes visible
//        barrier();             // Synchronizes all threads in workgroup
//
//
//    }


}