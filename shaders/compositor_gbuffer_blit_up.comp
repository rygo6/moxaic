#version 450
#extension GL_KHR_shader_subgroup_basic  : require
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_debug_printf : require

#define LOCAL_SIZE 4
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform State {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} state;
layout (set = 0, binding = 1) uniform sampler2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer[];

const ivec2 gatherOffsets[4] = {
{ 0, 1 },
{ 1, 1 },
{ 1, 0 },
{ 0, 0 },
};

float Lerp(float a, float b, float t) {
    return a + ((b - a) * t);
}

vec4 LinearizeDepth(vec4 zNear, vec4 zFar, vec4 projectionDepth) {
    return zNear * zFar / (zFar - projectionDepth * (zFar - zNear));
}

vec4 ProjectDepth(vec4 newNear, vec4 newFar, vec4 linearDepth) {
    return (newFar * (linearDepth - newNear)) / (linearDepth * (newFar - newNear));
}

uint SubgroupOffsetIndex(ivec2 dxdy) {
   return gl_SubgroupInvocationID + dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

uint SubgroupIndex(ivec2 dxdy) { ;
    return dxdy.x + (dxdy.y * gl_WorkGroupSize.x);
}

float AverageNonZeroQuad(vec4 quad){
    float count = 0.0f;
    float sum = 0.0f;
    for (int i = 0; i < 4; ++i) {
        count += quad[i] > 0.0f ? 1.0f : 0.0f;
        sum += quad[i];
    }
    return int(count) > 0 ? sum / count : 0;
}

void main()
{
    ivec2 dstSize = imageSize(dstGbuffer[0]);

    // * 2 because initial sample is 2x2 textureGather
    ivec2 coord0 = ivec2(gl_GlobalInvocationID.xy) * 2;
    vec2 quadCenterUV = vec2(coord0 + 1) / vec2(dstSize);

    vec4 gatheredDepth = textureGather(srcDepth, quadCenterUV, 0);
    vec4 gatheredLinearDepth = LinearizeDepth(vec4(state.depth.nearZ), vec4(state.depth.farZ), gatheredDepth);
    vec4 gatheredProjectedDepth = ProjectDepth(vec4(state.cameraFarZ), vec4(state.cameraNearZ), gatheredLinearDepth); // reverse near/far because we use reverseZ

    float depth0 = AverageNonZeroQuad(gatheredProjectedDepth);
    float depth1 = AverageNonZeroQuad(vec4(depth0,
        subgroupShuffle(depth0, SubgroupOffsetIndex(ivec2(1, 0))),
        subgroupShuffle(depth0, SubgroupOffsetIndex(ivec2(0, 1))),
        subgroupShuffle(depth0, SubgroupOffsetIndex(ivec2(1, 1)))));
    float depth2 = AverageNonZeroQuad(vec4(depth1,
        subgroupShuffle(depth1, SubgroupOffsetIndex(ivec2(2, 0))),
        subgroupShuffle(depth1, SubgroupOffsetIndex(ivec2(0, 2))),
        subgroupShuffle(depth1, SubgroupOffsetIndex(ivec2(2, 2)))));

    ivec2 coord1Sample = ivec2(gl_LocalInvocationID.xy / 2) * 2;
    ivec2 coord2Sample = ivec2(gl_LocalInvocationID.xy / 4) * 4;
    depth1 = subgroupShuffle(depth1, SubgroupIndex(coord1Sample));
    depth2 = subgroupShuffle(depth2, SubgroupIndex(coord2Sample));
    float finalDepth = depth0 > 0 ? depth0 : depth1 > 0 ? depth1 : depth2;

    for (int i = 0; i < 4; ++i) {
        float finalDepth = gatheredProjectedDepth[i] > 0 ? gatheredProjectedDepth[i] :
            depth0 > 0 ? depth0 :
            depth1 > 0 ? depth1 :
            depth2;
        imageStore(dstGbuffer[0], coord0 + gatherOffsets[i], vec4(finalDepth));
    }
}