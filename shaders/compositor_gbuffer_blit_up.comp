#version 450
#extension GL_KHR_shader_subgroup_basic  : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_debug_printf : require

#include "math.glsl"
#include "subgroup_grid.glsl"

layout (local_size_x = SUBGROUP_CAPACITY, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform State {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} state;
layout (set = 0, binding = 1) uniform sampler2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer[];

shared float depths3[WORKGROUP_SUBGROUP_COUNT]; // 64
shared float depths4[WORKGROUP_SUBGROUP_COUNT / (2 * 2)]; // 4 * 4 = 16
shared float depths5[WORKGROUP_SUBGROUP_COUNT / (4 * 4)]; // 2 * 2 = 4
shared float depth6; // 1

float AverageNonZeroQuad(vec4 quad){
    int count = 0;
    float sum = 0.0f;
    for (int i = 0; i < 4; ++i) {
        count += int(quad[i] > HALF_EPSILON);
        sum += quad[i];
    }
    return count > 0 ? sum / float(count) : 0;
}

void main()
{
    ivec2 outputSize = imageSize(dstGbuffer[0]);
    InitializeSubgroupGridQuadInfo(outputSize);

    vec2 quadCenterUV = vec2(grid_GlobalCoord + 1) / vec2(outputSize);
    vec4 gatheredDepth = textureGather(srcDepth, quadCenterUV, 0);
//    {   // The only reason this is important is for linear sampling the depth. If I don't linear sample the depth this is probably pointless
//        // But linear sampling depth might produce better results? Need to A/B test. However if I don't linearly sample then I can use imageLoad on
//        // the gbuffer in compute composite which which might be faster
//        const int expand = 31;
//        const ivec2 expandGatherOffsets[4] = { { -expand, expand }, { expand, expand }, { expand, -expand }, { -expand, -expand }, };
//        // its possible use subgroup operations is faster than this
//        vec4 expandGatheredDepth = textureGatherOffsets(srcDepth, quadCenterUV, expandGatherOffsets, 0);
//        for (int i = 0; i < 4; ++i) {
//            gatheredDepth[i] = gatheredDepth[i] > HALF_EPSILON ? gatheredDepth[i] : expandGatheredDepth[i];
//        }
//    }

    vec4 gatheredLinearDepth = LinearizeDepth(vec4(state.depth.nearZ), vec4(state.depth.farZ), gatheredDepth);
    vec4 gatheredProjectedDepth = ProjectDepth(vec4(state.cameraFarZ), vec4(state.cameraNearZ), gatheredLinearDepth); // reverse near/far because we use reverseZ

    vec4 depth0Quad = gatheredProjectedDepth;
    float depth1 = AverageNonZeroQuad(gatheredProjectedDepth);
    float depth2 = 0;
    float depth3 = 0;

    {
        // Subgroup averaging
        vec4 depth1Shuffle = vec4(
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(0, 1))),
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(1, 1))),
            subgroupShuffle(depth1, SubgroupIndexFromOffset(ivec2(1, 0))),
            depth1);

        ivec2 depth2RootSubgroupCoord = ivec2(grid_SubgroupCoord / 2) * 2;
        uint depth2RootSubgroupIndex = SubgroupIndexFromCoord(depth2RootSubgroupCoord);
        if (depth2RootSubgroupIndex == grid_SubgroupIndex)
            depth2 = AverageNonZeroQuad(depth1Shuffle);
        subgroupBarrier();

        depth2 = subgroupShuffle(depth2, depth2RootSubgroupIndex);

        vec4 depth2Shuffle = vec4(
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(0, 2))),
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(2, 2))),
            subgroupShuffle(depth2, SubgroupIndexFromOffset(ivec2(2, 0))),
            depth2);

        ivec2 depth3RootSubgroupCoord = ivec2(grid_SubgroupCoord / 4) * 4;
        uint depth3RootSubgroupIndex = SubgroupIndexFromCoord(depth3RootSubgroupCoord);
        if (depth3RootSubgroupIndex == grid_SubgroupIndex){
            depth3 = AverageNonZeroQuad(depth2Shuffle);
            depths3[grid_LocalSubgroupIndex] = depth3;
        }
        subgroupBarrier();

        depth3 = subgroupShuffle(depth3, depth3RootSubgroupIndex);

        barrier();
    }

    float depth4 = 0;

    { // Workgroup averaging
        ivec2 depth4RootLocalWorkgroupCoord = ivec2(grid_LocalSubgroupCoord / 4) * 4;

        ivec2 depth4SharedCoord = ivec2(grid_LocalSubgroupID / 2);
        uint depth4SharedIndex = IndexFromID(depth4SharedCoord, WORKGROUP_SQUARE_SIZE / 2);

//        ivec2 depth4RootLocalWorkgroupCoord = depth4SharedCoord * 2;
//        uint depth4RootLocalWorkgroupIndex = LocalWorkgroupIndexFromCoord(depth4RootLocalWorkgroupCoord);

        if (grid_LocalSubgroupIndex == 16){
            debugPrintfEXT("%d  %d  %d\n", depth4SharedIndex, depth4SharedCoord.x, depth4SharedCoord.y);
        }

//        ivec2 depth5SharedID = ivec2(grid_LocalWorkgroupID / 4);
//        uint depth5SharedIndex = IndexFromID(depth5SharedID, WORKGROUP_SQUARE_SIZE / 4);
//        ivec2 depth5RootLocalWorkgroupID = depth5SharedID * 4;

//        ivec2 depth6RootLocalWorkgroupID = ivec2(0, 0); // ivec2(grid_LocalWorkgroupID / 8) * 8;

        if (depth4RootLocalWorkgroupCoord == grid_LocalSubgroupCoord) {
            vec4 depth3Shuffle = vec4(
                depths3[LocalWorkgroupIndexFromOffset(ivec2(0, 1))],
                depths3[LocalWorkgroupIndexFromOffset(ivec2(1, 1))],
                depths3[LocalWorkgroupIndexFromOffset(ivec2(1, 0))],
                depth3);
            depths4[depth4SharedIndex] = AverageNonZeroQuad(depth3Shuffle);
        }

        barrier();

        depth4 = depths4[depth4SharedIndex];
    }

//    if (gl_LocalInvocationIndex == 0) {
//        float minDepth = 1.0;
//        for (int i = 0; i < WORKGROUP_SUBGROUP_COUNT; i++)
//            minDepth = depths3[i] > HALF_EPSILON ? min(minDepth, depths3[i]) : minDepth;
//
//        depth6 = minDepth < 1.0 ?  minDepth : 0;
//    }

//    barrier();

    for (int i = 0; i < 4; ++i) {
        float finalDepth = depth0Quad[i] > 0 ? depth0Quad[i] :
            depth1 > 0 ? depth1 :
            depth2 > 0 ? depth2 :
            depth3 > 0 ? depth3 :
            depth4;
        imageStore(dstGbuffer[0], grid_GlobalCoord + quadGatherOffsets[i], vec4(finalDepth));
    }
}