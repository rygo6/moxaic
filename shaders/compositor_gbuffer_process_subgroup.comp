#version 450

#extension GL_KHR_shader_subgroup_basic  : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_quad : require

#include "math.glsl"
#include "subgroup_grid.glsl"
#include "logging.glsl"

layout (local_size_x = SUBGROUP_COUNT, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

struct DepthState {
    float minDepth;
    float maxDepth;
    float nearZ;
    float farZ;
};

layout (set = 0, binding = 0) uniform ProcessState {
    DepthState depth;
    float cameraNearZ;
    float cameraFarZ;
} processState;
layout (set = 0, binding = 1) uniform sampler2D srcDepth;
layout (set = 0, binding = 2, rgba16f) uniform image2D dstGbuffer;

float sharedDepth1; // share via subgroup
shared float sharedDepth2[64]; // 8 * 8 = 64  WORKGROUP_SUBGROUP_COUNT / 1
shared float sharedDepth3[16]; // 4 * 4 = 16  WORKGROUP_SUBGROUP_COUNT / 4
shared float sharedDepth4[4];  // 2 * 2 = 4   WORKGROUP_SUBGROUP_COUNT / 16
shared float sharedDepth5;     // 1

//vec4 testDepths = vec4(0.2, 0.0, .8, 1.0);

void main()
{
    ivec2 outputSize = imageSize(dstGbuffer);
    InitializeSubgroupGridInfo(outputSize);

    if (any(greaterThanEqual(grid_GlobalInvocationQuadMortonCoord, outputSize)))
        return;

    float depthSample = texture(srcDepth, grid_GlobalInvocationMortonUV).r;
    float linearDepth = LinearizeDepth(processState.depth.nearZ, processState.depth.farZ, depthSample);
    float projectedDepth = ProjectDepth(processState.cameraFarZ, processState.cameraNearZ, linearDepth); // reverse near/far because we use reverseZ

    float depth[6];
    depth[0] = projectedDepth;

/*
    Four groups of four depth0 samples in 4x4 subgroup.

    morton layout
      0  1     2  3
    0 00 01    04 05
    1 02 03    06 07

    2 08 09    12 13
    3 10 11    14 15

    linear layout
      0  1     2  3
    0 00 01    02 03
    1 04 05    06 07

    2 08 09    10 11
    3 12 13    14 15
*/
    {
        uint quadID = grid_InvocationSubgroupQuadID % 4;
        uint rootSampleMortonID = MortonQuadRoot(gl_SubgroupInvocationID);
        uvec2 invocatioNMortonCoord = MortonDecode4bit(quadID);

        uvec4 shuffleIndices = MortonQuad(rootSampleMortonID);
        vec4 shuffleDepths = vec4(
            subgroupShuffle(depth[0], shuffleIndices.x),
            subgroupShuffle(depth[0], shuffleIndices.y),
            subgroupShuffle(depth[0], shuffleIndices.z),
            subgroupShuffle(depth[0], shuffleIndices.w)
        );

        float average = AverageQuadOmitZero(shuffleDepths);
        shuffleDepths = ReplaceZero(shuffleDepths, average);
        vec2 quadT = vec2(invocatioNMortonCoord);
        depth[1] = LerpQuad(quadT, shuffleDepths);

        // We shuffle by subgroups so set on every thread
        sharedDepth1 = average;
    }

/*
    One group of four depth1 samples in 4x4 subgroup.
      0    1
    0 1    1

    1 1    1

    Max subgroup size across NV and AMD is 32.
    So there are are two 4x4 subgroup squares which this operation can occur on.
    After this it must use shared memory.
*/
    {
        uint sampleMortonID = grid_InvocationSubgroupQuadID + grid_InvocationSubgroupQuadBaseID;
        uint rootSampleMortonID = MortonQuadRootAtLevel(sampleMortonID, 2);
        uint invocationQuadSize = SUBGROUP_SQUARE_SIZE;
        uvec2 invocationMortonCoord = grid_InvocationSubgroupQuadMortonCoord;

        uvec4 shuffleIndices = MortonQuadAtLevel(rootSampleMortonID, 1);
        vec4 shuffleDepths = vec4(
            subgroupShuffle(sharedDepth1, shuffleIndices.x),
            subgroupShuffle(sharedDepth1, shuffleIndices.y),
            subgroupShuffle(sharedDepth1, shuffleIndices.z),
            subgroupShuffle(sharedDepth1, shuffleIndices.w)
        );

        float average = AverageQuadOmitZero(shuffleDepths);
        vec2 quatT = vec2(invocationMortonCoord) / vec2(invocationQuadSize - 1);
        shuffleDepths = ReplaceZero(shuffleDepths, average);

        if (grid_InvocationSubgroupQuadID == 0)
            sharedDepth2[grid_SubgroupQuadID] = average;

        barrier();
    }

/*
    Each workgroup is a subgroup square of 4x4.
    depth2 has 8 x 8 workgroups.
    depth2 is 32x32 samples in total.

      0  1  2  3  4  5  6  7
    0 00 01 02 03 04 05 06 07
    1 08 09 10 11 12 13 14 15
    2 16 17 18 19 20 21 22 23
    3 24 25 26 27 28 29 30 31
    4 32 33 34 35 36 37 38 39
    5 40 41 42 43 44 45 46 47
    6 48 49 50 51 52 53 54 55
    7 56 57 58 59 60 61 62 63
*/

    {
        const uint level = 1;
        const uint levelSquare = 2;

        uint sampleMortonID = grid_SubgroupQuadID;
        uint rootSampleMortonID = MortonQuadRootAtLevel(sampleMortonID, 1);
        uvec4 shuffleIndices = MortonQuadAtLevel(rootSampleMortonID, 0);
        vec4 shuffleDepths = vec4(
            sharedDepth2[shuffleIndices.x],
            sharedDepth2[shuffleIndices.y],
            sharedDepth2[shuffleIndices.z],
            sharedDepth2[shuffleIndices.w]
        );

        uint invocationQuadSize = SUBGROUP_SQUARE_SIZE * 2;
        uvec2 invocationMortonCoord = grid_InvocationQuadMortonCoord % invocationQuadSize;

        vec2 quatT = vec2(invocationMortonCoord) / vec2(invocationQuadSize - 1);
        float average = AverageQuadOmitZero(shuffleDepths);
        shuffleDepths = ReplaceZero(shuffleDepths, average);
        depth[3] = LerpQuad(quatT, shuffleDepths);

        if (grid_InvocationSubgroupQuadID == 0 && sampleMortonID == rootSampleMortonID)
            sharedDepth3[sampleMortonID] = average;

        barrier();

    }

/*
      0  1  2  3
    0 00 01 02 03
    1 04 05 06 07
    2 08 09 10 11
    3 12 13 14 15
*/
    {
        const uint level = 2;
        const uint levelSquare = 4;
        uint sampleMortonID = grid_SubgroupQuadID;
        uint rootSampleMortonID = MortonQuadRootAtLevel(sampleMortonID, 2);
        uint invocationQuadSize = SUBGROUP_SQUARE_SIZE * 4;
        uvec2 invocationMortonCoord = grid_InvocationQuadMortonCoord % invocationQuadSize;

        uvec4 shuffleIndices = MortonQuadAtLevel(rootSampleMortonID, 1) / 4;
        vec4 shuffleDepths = vec4(
            sharedDepth3[shuffleIndices.x],
            sharedDepth3[shuffleIndices.y],
            sharedDepth3[shuffleIndices.z],
            sharedDepth3[shuffleIndices.w]
        );

        vec2 quatT = vec2(invocationMortonCoord) / vec2(invocationQuadSize - 1);
        float average = AverageQuadOmitZero(shuffleDepths);
        shuffleDepths = ReplaceZero(shuffleDepths, average);
        depth[4] = LerpQuad(quatT, shuffleDepths);

        if (grid_InvocationSubgroupQuadID == 0 && sampleMortonID == rootSampleMortonID)
            sharedDepth4[sampleMortonID / 16] = average;

        barrier();
    }

/*
      0  1
    0 00 01
    1 02 03
*/
    {
        const uint level = 3;
        const uint levelSquare = 8;
        uint sampleMortonID = grid_SubgroupQuadID;
        uint rootSampleMortonID = MortonQuadRootAtLevel(sampleMortonID, 3);
        uint invocationQuadSize = SUBGROUP_SQUARE_SIZE * 8;
        uvec2 invocationMortonCoord = grid_InvocationQuadMortonCoord % invocationQuadSize;

        uvec4 shuffleIndices = MortonQuadAtLevel(rootSampleMortonID, 2) / 16;
        vec4 shuffleDepths = vec4(
            sharedDepth4[shuffleIndices.x],
            sharedDepth4[shuffleIndices.y],
            sharedDepth4[shuffleIndices.z],
            sharedDepth4[shuffleIndices.w]
        );

        vec2 quatT = vec2(invocationMortonCoord) / vec2(invocationQuadSize - 1);
        float average = AverageQuadOmitZero(shuffleDepths);
        shuffleDepths = ReplaceZero(shuffleDepths, average);
        depth[5] = LerpQuad(quatT, shuffleDepths);
    }

    float finalDepth =
            depth[0] > HALF_EPSILON ? depth[0] :
            depth[1] > HALF_EPSILON ? depth[1] :
            depth[2] > HALF_EPSILON ? depth[2] :
            depth[3] > HALF_EPSILON ? depth[3] :
            depth[4] > HALF_EPSILON ? depth[4] :
            depth[5];
    imageStore(dstGbuffer, ivec2(grid_GlobalInvocationQuadMortonCoord), vec4(finalDepth));
}
