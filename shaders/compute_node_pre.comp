#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 5, r32ui) uniform uimage2D outputAveragedAtomic;

vec3 nodeOriginWorldPos = vec3(0, 0, -.5);
vec3 nodeOriginWorldDirection = vec3(0, 0, -1);
const uint maxUint = 0xFFFFFFFFu;

const vec2 ndcCorners[] = {
{ -1, 1 },
{ 1, -1 },
};


float CalcNodeZPlane(){

    vec2 uvs[ndcCorners.length()];
    for (int i = 0; i < ndcCorners.length(); ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 0));
//        if (ndc.z < 0) {
//            return 1;// maybe -z?
//        }
        uvs[i] = UVFromNDC(ndc);
    }
    const float frontMag = SqrMag(uvs);

    for (int i = 0; i < ndcCorners.length(); ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 1));
        uvs[i] = UVFromNDC(ndc);
    }
    const float backMag = SqrMag(uvs);

    const float nodeZPlane = frontMag < backMag ? 1 : -1;

    return nodeZPlane;
}

void NodeIntersectUV(const vec2 uv, out vec3 intersectNodeNDC, out float nodeDepthSample)
{
    const vec2 ndc = NDCFromUV(1 - uv);// why do I 1 - uv here?! It does flip it to proper layout
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);
    const vec4 intersectGlobalClipPos = GlobalClipPosFromWorldPos(intersectWorldPos);
    const vec3 intersectGlobalNDC = NDCFromClipPos(intersectGlobalClipPos);
    const vec4 intersectNodeClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    intersectNodeNDC = NDCFromClipPos(intersectNodeClipPos);
    const vec2 intersectNodeUV = UVFromNDC(intersectNodeNDC);
    nodeDepthSample = texture(nodeDepthTexture, intersectNodeUV).r;
}

const vec2 samplesOffsets[] = {
{ 0.5, 0.5 },
{ 0.0, 0.0 },
{ 1.0, 0.0 },
{ 1.0, 1.0 },
{ 0.0, 1.0 },
};

void main()
{
//    nodeOriginWorldPos.z = CalcNodeZPlane() * 0.5;

    const ivec2 iScreenSize = ivec2(globalUBO.width / LOCAL_SIZE, globalUBO.height / LOCAL_SIZE);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = UVFromCoord(coord, screenSize);
    const vec2 ndc = NDCFromUV(uv);
    const ivec2 offsetCoord = coord + ivec2(1, 1);
    const vec2 offsetUV = UVFromCoord(offsetCoord, screenSize);

    const int sampleCount = samplesOffsets.length();
    vec3 intersectNodeNDCs[samplesOffsets.length()];
    float minDepthSample = 1;
    int validSampleCount = 0;
    for (int i = 0; i < sampleCount; ++i){
        const vec2 sampleUV = mix(uv, offsetUV, samplesOffsets[i]);
        float depthSample;
        NodeIntersectUV(sampleUV, intersectNodeNDCs[i], depthSample);
        minDepthSample = min(depthSample, minDepthSample);
        validSampleCount += depthSample > .99 ? 0 : 1;
    }
    if (validSampleCount == 0){
        return;
    }

    const vec3 depthProjectedGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[0].xy, minDepthSample));
    const vec2 depthProjectGlobalUV = UVFromNDC(depthProjectedGlobalNDC);
    const ivec2 depthProjectGlobalCoord = CoordFromUV(depthProjectGlobalUV, screenSize);
    const uint data = PackFloatToUint32(depthProjectedGlobalNDC.z);
    imageAtomicMin(outputAveragedAtomic, depthProjectGlobalCoord, data);

    const vec3 ulDepthProjectGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[1].xy, minDepthSample));
    const vec2 ulDepthProjectGlobalUV = UVFromNDC(ulDepthProjectGlobalNDC);
    const vec3 lrDepthProjectGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[3].xy, minDepthSample));
    const vec2 lrDepthProjectGlobalUV = UVFromNDC(lrDepthProjectGlobalNDC);

//    if (lrDepthProjectGlobalUV.x < 0 || lrDepthProjectGlobalUV.y < 0 || ulDepthProjectGlobalUV.x > 1 || ulDepthProjectGlobalUV.y > 1) {
//        return;
//    }

//    const vec2 uvDiff = lrDepthProjectGlobalUV - ulDepthProjectGlobalUV;
//    const uint packed_x_y_size = PackUint32FromF12F12F8(ulDepthProjectGlobalUV.x, ulDepthProjectGlobalUV.y, uvDiff.y);
//    const uint packed_depth_id = PackUint32FromF24UI8(depthProjectedGlobalNDC.z, 0);

    const uint tileIndex = atomicAdd(tileBuffer.command.x, 1);
//    tileBuffer.tiles[tileIndex] =  Tile(packed_x_y_size, packed_depth_id);
    tileBuffer.tiles[tileIndex] =  Tile(ulDepthProjectGlobalUV.x, ulDepthProjectGlobalUV.y, lrDepthProjectGlobalUV.x, lrDepthProjectGlobalUV.y, depthProjectedGlobalNDC.z);

//    debugPrintfEXT("%d | %f | %f | %f | %d | %d", tileIndex, tile.x, tile.y, tile.size, tile.id);

    //    if (gl_GlobalInvocationID.x == 16 && gl_GlobalInvocationID.y == 16) {
    //        debugPrintfEXT("%f | %f | %F", depthProjectedNodeClipPos.x, depthProjectedNodeClipPos.y, depthProjectedNodeClipPos.z);
    //        imageAtomicMin(outputAveragedAtomic, coord, 0);
    //    }
}
