#version 450
//#extension GL_EXT_debug_printf : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 5, r32ui) uniform uimage2DMS outputAveragedAtomic;

vec3 nodeOriginWorldPos = vec3(0, 0, 0);
vec3 nodeOriginWorldDirection = vec3(0, 0, -1);
const uint maxUint = 0xFFFFFFFFu;

bool NodeIntersectUV(const vec2 uv, out vec3 intersectGlobalNDC, out vec3 intersectNodeNDC, out float nodeDepthSample)
{
    const vec2 ndc = NDCFromUV(1 - uv);// why do I 1 - uv here?! It does flip it to proper layout
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 intersectGlobalClipPos = GlobalClipPosFromWorldPos(intersectWorldPos);
    intersectGlobalNDC = NDCFromClipPos(intersectGlobalClipPos);

    const vec4 intersectNodeClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    intersectNodeNDC = NDCFromClipPos(intersectNodeClipPos);

    const vec2 intersectNodeUV = UVFromNDC(intersectNodeNDC);
    const vec3 nodeWorldNormalSample = texture(nodeNormalTexture, intersectNodeUV).xyz * vec3(1, -1, 1);// I encoded y = up on sphere normals
    nodeDepthSample = texture(nodeDepthTexture, intersectNodeUV).r;

    if (intersectNodeUV.x < 0
    || intersectNodeUV.x > 1
    || intersectNodeUV.y < 0
    || intersectNodeUV.y > 1
    || nodeDepthSample > .99
    //    || dot(nodeWorldNormalSample.xyz, globalWorldRay) < 0
    ) {
        return false;
    }

    return true;
}

vec3 CalcNormal(vec3 P1, vec3 P2, vec3 P3) {
    vec3 edge1 = P2 - P1;
    vec3 edge2 = P3 - P1;
    vec3 normal = cross(edge1, edge2);
    return normalize(normal);
}

uint PackUintFromVec3(vec3 v) {
    uint r = uint(v.r * 255.0);
    uint g = uint(v.g * 255.0);
    uint b = uint(v.b * 255.0);
    return (r << 16) | (g << 8) | b;
}

uint PackUintFrom16F8F8F(float float1, float float2, float float3) {
    uint int1 = uint(float1 * 65535.0);// 16 bits
    uint int2 = uint(float2 * 255.0);// 8 bits
    uint int3 = uint(float3 * 255.0);// 8 bits
    uint packed = (int1 << 16) | (int2 << 8) | int3;
    return packed;
}

uint packFloatToUint32(float value) {
    value = clamp(value, 0.0, 1.0);
    float scaled = value * 4294967295.0;
    uint packed = uint(scaled);
    return packed;
}

float unpackUint32ToFloat(uint packed) {
    float value = float(packed);
    return value / 4294967295.0;
}

vec3 GlobalNDCFromNodeNDC(vec3 nodeNDC){
    const vec4 nodeClipPos = ClipPosFromNDC(nodeNDC);
    const vec3 worldPos = WorldPosFromNodeClipPos(nodeClipPos);
    const vec4 globalClipPos = GlobalClipPosFromWorldPos(worldPos);
    const vec3 globalNDC = NDCFromClipPos(globalClipPos);
    return globalNDC;
}

const vec2 samplesOffsets[] = {
{ 0.5, 0.5 },
{ 0.0, 0.0 },
{ 1.0, 0.0 },
{ 1.0, 1.0 },
{ 0.0, 1.0 },
};

void main()
{
    const ivec2 iScreenSize = ivec2(globalUBO.width / LOCAL_SIZE, globalUBO.height / LOCAL_SIZE);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = UVFromCoord(coord, screenSize);
    const vec2 ndc = NDCFromUV(uv);
    const ivec2 offsetCoord = coord + ivec2(1, 1);
    const vec2 offsetUV = UVFromCoord(offsetCoord, screenSize);

    const int sampleCount = samplesOffsets.length();
    float depthSamples[samplesOffsets.length()];
    vec3 intersectNodeNDCs[samplesOffsets.length()];
    float minDepthSample = 1;
    vec3 farthestIntersectNodeNDC = vec3(0, 0, 0);
    vec3 maxIntersectGlobalNDC = vec3(0, 0, 0);
    int validSampleCount = 0;
    for (int i = 0; i < sampleCount; ++i){
        const vec2 sampleUV = mix(uv, offsetUV, samplesOffsets[i]);
        vec3 intersectGlobalNDC;
        float depthSample;
        if (!NodeIntersectUV(sampleUV, intersectGlobalNDC, intersectNodeNDCs[i], depthSample)) {
            continue;
        }
        minDepthSample = min(depthSample, minDepthSample);
        if (intersectGlobalNDC.z > maxIntersectGlobalNDC.z) {
            maxIntersectGlobalNDC = intersectGlobalNDC;
            farthestIntersectNodeNDC = intersectNodeNDCs[i];
        }
        validSampleCount++;
    }
    if (validSampleCount == 0){
        return;
    }

    const vec3 depthProjectedGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[0].xy, minDepthSample));
    const vec2 depthProjectGlobalUV = UVFromNDC(depthProjectedGlobalNDC);
    const ivec2 depthProjectGlobalCoord = CoordFromUV(depthProjectGlobalUV, screenSize);
    const uint data = packFloatToUint32(depthProjectedGlobalNDC.z);
    imageAtomicMin(outputAveragedAtomic, depthProjectGlobalCoord, 0, data);

    const vec3 ulDepthProjectGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[1].xy, minDepthSample));
    const vec2 ulDepthProjectGlobalUV = UVFromNDC(ulDepthProjectGlobalNDC);
    const vec3 lrDepthProjectGlobalNDC = GlobalNDCFromNodeNDC(vec3(intersectNodeNDCs[3].xy, minDepthSample));
    const vec2 lrDepthProjectGlobalUV = UVFromNDC(lrDepthProjectGlobalNDC);
    const vec2 uvDiff = lrDepthProjectGlobalUV - ulDepthProjectGlobalUV;
    Tile tile = Tile(float16_t(ulDepthProjectGlobalUV.x), float16_t(ulDepthProjectGlobalUV.y), uint8_t(uvDiff.x * 256), uint8_t(0));

    uint tileIndex = atomicAdd(atomicTileBuffer.atomicTileCount, 1);
    atomicTileBuffer.tiles[tileIndex] = tile;

//    debugPrintfEXT("%d | %f | %f | %f | %d | %d", tileIndex, tile.x, tile.y, tile.size, tile.id);

    //    if (gl_GlobalInvocationID.x == 16 && gl_GlobalInvocationID.y == 16) {
    //        debugPrintfEXT("%f | %f | %F", depthProjectedNodeClipPos.x, depthProjectedNodeClipPos.y, depthProjectedNodeClipPos.z);
    //        imageAtomicMin(outputAveragedAtomic, coord, 0);
    //    }
}
