#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct MeshTaskPayload
{
    vec4 ulClipPos, urClipPos, lrClipPos, llClipPos;
    vec3 ulNDC, urNDC, lrNDC, llNDC;
};

MeshTaskPayload payload;

vec3 intersectRayPlane(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal) {
    float facingRatio = dot(planeNormal, rayDir);
    float t = dot(planePoint - rayOrigin, planeNormal) / facingRatio;
    return (facingRatio < 0) ? (rayOrigin + t * rayDir) : vec3(0,0,0);
}

// https://jcgt.org/published/0011/03/04/paper-lowres.pdf
float area(vec2 a, vec2 b) { return (a.x*b.y)-(a.y*b.x); }
vec2 barycentricQuadUV(vec2 ndc) {
    const float w[4] = { payload.ulClipPos.w, payload.urClipPos.w, payload.lrClipPos.w, payload.llClipPos.w };
    const vec2 v[4] = { payload.ulNDC.xy, payload.urNDC.xy, payload.lrNDC.xy, payload.llNDC.xy };
    float r[4], t[4], u[4], f[4];
    vec2 s[4];
    for (int i = 0; i < 4; i++) {
        s[i] = v[i] - ndc;
        r[i] = length(s[i]) * sign(w[i]);
    }
    for (int i = 0; i < 4; i++) {
        float A = area(s[i], s[(i + 1) % 4]);
        float D = dot(s[i], s[(i + 1) % 4]);
        t[i] = (r[i] * r[(i + 1) % 4] - D) / A;
    }
    for (int i = 0; i < 4; i++) {
        u[i] = (t[(i + 3) % 4] + t[i]) / r[i];
    }
    const vec4 wt = vec4(u[0], u[1], u[2], u[3]) / (u[0] + u[1] + u[2] + u[3]);
    for (int i = 0; i < 4; i++) {
        f[i] =  wt[i] / w[i];
    }
    const vec2 ulUV = vec2(0, 1), urUV = vec2(1, 1), lrUV = vec2(1, 0), llUV = vec2(0, 0);
    return (f[0] * ulUV + f[1] * urUV + f[2] * lrUV + f[3] * llUV) / (f[0] + f[1] + f[2] + f[3]);
}

vec4 toNodeWorldPos(vec4 clipPos)
{
    vec4 worldPos = nodeUBO.invView * nodeUBO.invProj * clipPos;
    return worldPos;
}

vec3 ClipPosToNDC(vec4 clipPos)
{
    return clipPos.xyz / clipPos.w;
}

vec2 UVToNDC(vec2 uv)
{
    return vec2(vec2(1, -1) * (uv * 2 - 1));;
}

vec2 NDCToUV(vec3 ndc)
{
    return (vec2((vec2(1, -1) * ndc.xy) + 1) * 0.5);
}

void main()
{
    const mat4 nodeProjView = nodeUBO.proj * nodeUBO.view;
    const vec4 nodeOriginClipPos = nodeProjView * vec4(0, 0, 0, 1);
    const vec4 nodeDirection = nodeProjView * vec4(0, 0, -1, 0); // -1 face towards view

    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 revCoord = ivec2(globalUBO.width - coord.x, coord.y); // honestly dont quite understand why this revcoord is needed compared to mesh shader
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const vec2 uv = vec2(revCoord) / screenSize;
    const vec2 ndc = UVToNDC(uv);

    const vec3 intersectWorldPos = intersectRayPlane(vec3(ndc,0), vec3(0,0,1), nodeOriginClipPos.xyz, nodeDirection.xyz);
    const vec4 intersectClipPos = nodeProjView * vec4(intersectWorldPos, 1);
    const vec3 intersectNDC = ClipPosToNDC(intersectClipPos);
    const vec2 intersectUV = NDCToUV(intersectNDC);

    const vec2 nodeQuadUV = intersectUV;
    const vec4 color = texture(nodeColor, nodeQuadUV);
//    const vec4 normal = texture(nodeNormal, nodeQuadUV);
//    const vec4 gBuffer = texture(nodeGBuffer, nodeQuadUV);
    const float depth = texture(nodeDepth, nodeQuadUV).r;

    const vec3 sRGB = pow(color.rgb, vec3(1.0 / 2.2));

    const vec2 nodeQuadNDC = UVToNDC(nodeQuadUV);
    const vec4 nodeQuadClipPos = vec4(nodeQuadNDC.xy, depth, 1);
    const vec4 nodeQuadWorldPos = toNodeWorldPos(nodeQuadClipPos);

    const vec4 newClipPos = globalUBO.proj * globalUBO.view * nodeQuadWorldPos;
    const vec3 newNDC = newClipPos.xyz / newClipPos.w;
    const vec2 newUV = NDCToUV(newNDC);
    const ivec2 newCoord = ivec2(round(newUV * screenSize));

    imageStore(outputColor, newCoord, vec4(sRGB, 1));
    //    imageStore(outputColor, newCoord + ivec2(0, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(-1, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, -1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(0, -1), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, -1), color);
}
