#version 450
//#extension GL_EXT_debug_printf : require

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

#define MXC_CAMERA_MIN_Z 0.0001f

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 5, r32ui) uniform readonly uimage2DMS outputAveragedAtomic;
layout (set = 1, binding = 6, r32ui) uniform uimage2D outputAtomic;
//layout (set = 1, binding = 7) uniform writeonly image2D outputColor;

vec3 nodeOriginWorldPos = vec3(0, 0, 0);
vec3 nodeOriginWorldDirection = vec3(0, 0, -1);

bool NodeIntersectUV(const vec2 uv, out vec2 nodeUV, out vec3 nodeWorldNormal, out vec3 stepNormalNDC, out vec3 depthProjectedNDC)
{
    const vec2 ndc = NDCFromUV(1 - uv);// why do I 1 - uv here?! It does flip it to proper layout
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);
    nodeUV = nodeIntersectUV;

    nodeWorldNormal = texture(nodeNormalTexture, nodeIntersectUV).xyz * vec3(1, -1, 1);// I encoded y = up on sphere normals
    const float nodeDepthSample = texture(nodeDepthTexture, nodeIntersectUV).r;

    if (nodeIntersectUV.x < 0
    || nodeIntersectUV.x > 1
    || nodeIntersectUV.y < 0
    || nodeIntersectUV.y > 1
    || nodeDepthSample > .99
    //    || dot(nodeWorldNormal.xyz, globalWorldRay) < 0
    ) {
        return false;
    }

    const vec4 nodeQuadDepthClipPos = vec4(nodeIntersectNDC.xy, nodeDepthSample, 1);
    const vec3 nodeQuadDepthWorldPos = WorldPosFromNodeClipPos(nodeQuadDepthClipPos);
    const vec4 nodeQuadDepthProjectedClipPos = GlobalClipPosFromWorldPos(nodeQuadDepthWorldPos);
    const vec3 nodeQuadDepthProjectedNDC = NDCFromClipPos(nodeQuadDepthProjectedClipPos);
    depthProjectedNDC = nodeQuadDepthProjectedNDC;

    const vec3 stepNormalWorldPos = nodeQuadDepthWorldPos + (nodeWorldNormal * 0.1);
    const vec4 stepNormalClipPos = GlobalClipPosFromWorldPos(stepNormalWorldPos);
    stepNormalNDC = NDCFromClipPos(stepNormalClipPos);

    return true;
}

void writeAtomicData(ivec2 coord, uint data){
    imageAtomicMin(outputAtomic, coord, data);
}

uint packFloatAnd565Color(float normalizedDepth, vec3 color) {
    uint packedValue = uint(normalizedDepth * 65535.0);

    uint r = uint(color.r * 31.0);
    uint g = uint(color.g * 63.0);
    uint b = uint(color.b * 31.0);
    uint packedColor = (r << 11) | (g << 5) | b;

    return (packedValue << 16) | packedColor;
}

void WriteDebugCoord(ivec2 debugCoord, ivec2 screenCoord){
    const vec2 diff = screenCoord - debugCoord;
    if (dot(diff, diff) < 100){
        const uint packedData = packFloatAnd565Color(0, vec3(0, 1, 1));
        writeAtomicData(screenCoord, packedData);
    }
}

void WriteDebugUV(vec2 debugUV, ivec2 screenCoord){
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const ivec2 debugCoord = CoordFromUV(debugUV, screenSize);
    WriteDebugCoord(debugCoord, screenCoord);
}

void WriteDebugNDC(vec3 ndc, ivec2 screenCoord){
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv, screenCoord);
}

void WriteDebugWorldPos(vec3 debugWorldPos, ivec2 screenCoord){
    const vec4 clipPos = GlobalClipPosFromWorldPos(debugWorldPos);
    const vec3 ndc = NDCFromClipPos(clipPos);
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv, screenCoord);
}

float inverseLerp(float value, float a, float b) {
    return a == b ? 0 : (value - a) / (b - a);
}

vec3 GlobalNDCFromNodeNDC(vec3 nodeNDC){
    const vec3 worldPos = WorldPosFromNodeClipPos(vec4(nodeNDC, 1));
    const vec4 globalClipPos = GlobalClipPosFromWorldPos(worldPos.xyz);
    const vec3 globalNDC = NDCFromClipPos(globalClipPos);
    return globalNDC;
}

float SqrMag(vec2 values[2]) {
    const  vec2 diff = values[0] - values[1];
    return dot(diff, diff);
}

const int ndcCornerCount = 2;
const vec2 ndcCorners[] = {
{ -1, 1 },
{ 1, -1 },
};

float CalcNodeZPlane(){

    vec2 uvs[ndcCornerCount];
    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 0));
        if (ndc.z < 0) {
            return 1;// maybe -z?
        }
        uvs[i] = UVFromNDC(ndc);
    }
    const float frontMag = SqrMag(uvs);

    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 1));
        uvs[i] = UVFromNDC(ndc);
    }
    const float backMag = SqrMag(uvs);

    float nodeZPlane = frontMag < backMag ? 1 : -1;
    if (abs(frontMag - backMag) < .1) {
        nodeZPlane = -1;
    }

    return nodeZPlane;
}

void main()
{
    const uint tileIndex = gl_WorkGroupID.x;
    if (tileIndex > tileBuffer.command.x) {
        return;
    }

    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);

    vec2 ulTileUV;
    float tileUVSize;
    UnpackF12F12F8FromUint32(tileBuffer.tiles[tileIndex].x_y_size, ulTileUV.x, ulTileUV.y, tileUVSize);

    float tileGlobalNDCZ;
    uint tileId;
    UnpackF24UI8FromUint32(tileBuffer.tiles[tileIndex].depth_id, tileGlobalNDCZ, tileId);

    if (tileGlobalNDCZ > .99) {
        return;
    }

    const ivec2 ulTileCoord = CoordFromUV(ulTileUV, screenSize);
    const vec2 ulTileNDC = NDCFromUV(ulTileUV);
    const vec4 ulClipPos = ClipPosFromNDC(ulTileNDC, tileGlobalNDCZ);
    const vec3 tileWorldPos = WorldPosFromGlobalClipPos(ulClipPos);

    const ivec2 screenCoord = ivec2(ulTileCoord + gl_LocalInvocationID.xy);
    const vec2 screenUV = UVFromCoord(screenCoord, screenSize);
    const vec2 screenNDC = NDCFromUV(screenUV);

    nodeOriginWorldPos = vec3(0, 0, tileWorldPos.z);
    nodeOriginWorldDirection = vec3(0, 0, -1);

//    if (gl_GlobalInvocationID.x == 0){
//        debugPrintfEXT("%f | %f | %f", ulTileUV.x, ulTileUV.y, tileGlobalNDCZ);
//    }

    // calc source pixel
    vec2 nodeUV;
    vec3 worldNormal;
    vec3 stepNormalNDC;
    vec3 depthProjectedNDC;
    if (!NodeIntersectUV(screenUV, nodeUV, worldNormal, stepNormalNDC, depthProjectedNDC)) {
        return;
    }

    // write source pixel
    const vec4 color = texture(nodeColorTexture, nodeUV);
    const uint packedData = packFloatAnd565Color(depthProjectedNDC.z, color.xyz);
    const vec2 depthProjectUV = UVFromNDC(depthProjectedNDC);
    const ivec2 depthProjectedCoord = CoordFromUV(depthProjectUV, screenSize);
    writeAtomicData(depthProjectedCoord, packedData);
    //    writeAtomicData(screenCoord, packedData);

    //    if (gl_GlobalInvocationID.x == 520 && gl_GlobalInvocationID.y == 520) {
    //        vec3 log = rAveragedNodeWorldPos;
    //        debugPrintfEXT("%f | %f | %f", log.x, log.y, log.z);
    //    }

    //    vec2 nodeUV2;
    //    vec3 worldNormal2;
    //    vec3 stepNormalNDC2;
    //    vec3 depthProjectedNDC2;
    //    if (!NodeIntersectUV(uv, nodeUV2, worldNormal2, stepNormalNDC2, depthProjectedNDC2)) {
    //        return;
    //    }
    //    const vec4 color2 = texture(nodeColorTexture, nodeUV2);
    //    const vec2 depthProjectUV2 = UVFromNDC(depthProjectedNDC2);
    //    const ivec2 depthProjectedCoord2 = CoordFromUV(depthProjectUV2, screenSize);
    //    const uint debugPackedData = packFloatAnd565Color(0, vec3(color2.x, 0, 0));
    //    writeAtomicData(depthProjectedCoord2, debugPackedData);
    //    const uint debugPackedData2 = packFloatAnd565Color(1, vec3(0, color2.y, 0));
    //    writeAtomicData(coord, debugPackedData2);


    // calc and write step normal pixel
    //    const vec2 stepNormalUV = UVFromNDC(stepNormalNDC);
    //    const vec2 stepNormalDir = stepNormalUV - uv;
    ////    const ivec2 stepNormalCoord = CoordFromUV(stepNormalUV, screenSize);
    //    vec2 normalizedStepNormalDir;
    //    bool stepNormalDirIsX;
    //    XYCoordNormalizedDir(stepNormalDir, stepNormalDirIsX, normalizedStepNormalDir);
    //    const ivec2 stepNormalCoord = iRound(normalizedStepNormalDir + vec2(depthProjectedCoord));
    //    writeAtomicData(stepNormalCoord, packedData);
    //    const ivec2 stepNormalCoord2 = iRound(2.0 * normalizedStepNormalDir + vec2(depthProjectedCoord));
    //    writeAtomicData(stepNormalCoord2, packedData);

    // calc stepback
    //    const vec2 stepBackDir = depthProjectUV - uv;
    //    vec2 normalizedStepBackDir;
    //    bool stepBackDirIsX;
    //    XYCoordNormalizedDir(stepBackDir, stepBackDirIsX, normalizedStepBackDir);
    //    const ivec2 stepBackCoord = iRound(normalizedStepBackDir + vec2(coord));
    //    const vec2 stepBackUV = uvFromCoord(stepBackCoord, screenSize);
    //    vec2 stepBackNodeUV;
    //    vec3 stepBackStepNormalNDC;
    //    vec3 stepBackProjectedNDC;
    //    if (!NodeIntersectUV(stepBackUV, stepBackNodeUV, stepBackStepNormalNDC, stepBackProjectedNDC)) {
    //        return;
    //    }

    // write stepback pixels
    //    const vec2 stepbackProjectedUV = UVFromNDC(stepBackProjectedNDC);
    //    const ivec2 stepbackOutputUVCoord = CoordFromUV(stepbackProjectedUV, screenSize);
    //    const ivec2 stepBackCoordDiff = abs(stepbackOutputUVCoord - depthProjectedCoord);
    //    const int stepbackCount = clamp((stepBackDirIsX ? stepBackCoordDiff.x : stepBackCoordDiff.y) - 1, 0, 4);// -1 so it doesn't overlap end pixel in stepback
    //    vec2 currentCoord = depthProjectedCoord;
    //    ivec2 roundedCoord = depthProjectedCoord;
    //    for (int step = 0; step < stepbackCount; ++step){
    //        currentCoord += normalizedStepBackDir;
    //        roundedCoord = iRound(currentCoord);
    //        writeAtomicData(roundedCoord, packedData);
    //    }
}
