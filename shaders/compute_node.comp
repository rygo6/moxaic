#version 450
#extension GL_EXT_debug_printf : require

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

#define MXC_CAMERA_MIN_Z 0.0001f

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 5, r32ui) uniform readonly uimage2D outputAveragedAtomic;
layout (set = 1, binding = 6, r32ui) uniform uimage2D outputAtomic;


vec3 nodeOriginWorldPos = vec3(0, 0, 0);
vec3 nodeOriginWorldDirection = vec3(0, 0, -1);

float inverseLerp(float value, float a, float b) {
    return (value - a) / (b - a);
}

bool NodeIntersect(const vec2 uv, out vec3 intersectNodeNDC, out vec3 depthProjectGlobalNDC)
{
    const vec2 ndc = NDCFromUV(uv);
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 worldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 worldRay = WorldRayDirFromGlobalNDC(ndc);
    vec3 intersectWorldPos;
    bool intersected = intersectRayPlane(worldPos, worldRay, nodeOriginWorldPos, nodeOriginWorldDirection, intersectWorldPos);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    intersectNodeNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(intersectNodeNDC);

    const vec3 nodeWorldNormal = texture(nodeNormalTexture, nodeIntersectUV).xyz * vec3(1, -1, 1);// I encoded y = up on sphere normals
    const float nodeDepthSample = SampleNodeDepth(nodeIntersectUV);
//    const float nodeDepthSample = 0;

    const vec3 depthProjectNodeNDC = vec3(intersectNodeNDC.xy, nodeDepthSample);
    depthProjectGlobalNDC = GlobalNDCFromNodeNDC(depthProjectNodeNDC);

    return intersected && nodeDepthSample < 1 && dot(nodeWorldNormal.xyz, worldRay) < 0;
}

void writeAtomicData(ivec2 coord, uint data){
    imageAtomicMin(outputAtomic, coord, data);
}

uint packFloatAnd565Color(float normalizedDepth, vec3 color) {
    uint packedValue = uint(normalizedDepth * 65535.0);

    uint r = uint(color.r * 31.0);
    uint g = uint(color.g * 63.0);
    uint b = uint(color.b * 31.0);
    uint packedColor = (r << 11) | (g << 5) | b;

    return (packedValue << 16) | packedColor;
}

void WriteDebugCoord(ivec2 debugCoord, ivec2 screenCoord){
    const vec2 diff = screenCoord - debugCoord;
    if (dot(diff, diff) < 30){
        const uint packedData = packFloatAnd565Color(0, vec3(1, 1, 0));
        writeAtomicData(screenCoord, packedData);
    }
}

void WriteDebugUV(vec2 debugUV, ivec2 screenCoord){
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const ivec2 debugCoord = CoordFromUV(debugUV, screenSize);
    WriteDebugCoord(debugCoord, screenCoord);
}

void WriteDebugNDC(vec3 ndc, ivec2 screenCoord){
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv, screenCoord);
}

void WriteDebugWorldPos(vec3 debugWorldPos, ivec2 screenCoord){
    const vec4 clipPos = GlobalClipPosFromWorldPos(debugWorldPos);
    const vec3 ndc = NDCFromClipPos(clipPos);
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv, screenCoord);
}

void WriteDebugLine(vec2 P1, vec2 P2, ivec2 screenCoord) {
    vec2 d = P2 - P1;
    vec2 Q = vec2(screenCoord);
    float crossProductZ = d.x * (Q.y - P1.y) - d.y * (Q.x - P1.x);

    float dotProduct = dot(Q - P1, d);
    float squaredSegmentLength = dot(d, d);
    bool isWithinSegment = dotProduct >= 0.0 && dotProduct <= squaredSegmentLength;

    WriteDebugCoord(ivec2(P1), screenCoord);

    if (abs(crossProductZ) < 100 && isWithinSegment){
        const uint packedData = packFloatAnd565Color(0,  vec3(0, 1, 1));
        writeAtomicData(screenCoord, packedData);
    }
}

void WriteDebugLine(vec3 P1, vec3 P2, ivec2 screenCoord) {
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);

    const vec4 p1ClipPos = GlobalClipPosFromWorldPos(P1);
    const vec3 p1NDC = NDCFromClipPos(p1ClipPos);
    const vec2 p1UV = UVFromNDC(p1NDC);
    const vec2 p1Coord = vec2(CoordFromUV(p1UV, screenSize));

    const vec4 p2ClipPos = GlobalClipPosFromWorldPos(P2);
    const vec3 p2NDC = NDCFromClipPos(p2ClipPos);
    const vec2 p2UV = UVFromNDC(p2NDC);
    const vec2 p2Coord = vec2(CoordFromUV(p2UV, screenSize));

    if (p1NDC.z > p2NDC.z){
        WriteDebugLine(p2Coord, p1Coord, screenCoord);
    } else {
        WriteDebugLine(p1Coord, p2Coord, screenCoord);
    }
}

void XYCoordNormalizedDir(const vec2 dir, out bool isXDir, out vec2 normalizedDir){
    const vec2 absDir = abs(dir);
    isXDir = absDir.x > absDir.y;
    const vec2 xNormalizedDir = dir * (1.0f / absDir.x);
    const vec2 yNormalizedDir = dir * (1.0f / absDir.y);
    normalizedDir = (isXDir ? xNormalizedDir : yNormalizedDir);
}

//const ivec2 averagedOffsets[] = {
//{ 0, 0 },
//{ 1, 0 },
//{ 0, 1 },
//{ 1, 1 },
//};


void main()
{
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 screenCoord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screenUV = UVFromCoord(screenCoord, screenSize);

    const ivec2 iAveragedScreenSize = ivec2(globalUBO.width / LOCAL_SIZE, globalUBO.height / LOCAL_SIZE);
    const vec2 averagedScreenSize = vec2(iAveragedScreenSize);
    const bool topTriangle =  gl_LocalInvocationID.y < gl_LocalInvocationID.x;

    const ivec2 averagedOffsetsTopTriangle[] = { { 0, 0 }, { 1, 1 }, { 1, 0 } };
    const ivec2 averagedOffsetsBottomTriangle[] = { { 0, 0 }, { 1, 1 }, { 0, 1 } };
    const ivec2 averagedOffsets[] = topTriangle ? averagedOffsetsTopTriangle : averagedOffsetsBottomTriangle;

    vec3 averagedWorldPos[3];
    for (int i = 0; i < 3; ++i) {
        const ivec2 averagedScreenCoord = ivec2(gl_WorkGroupID.xy) + averagedOffsets[i];
        const uint averagedAtomicData = imageLoad(outputAveragedAtomic, averagedScreenCoord).r;
        const float averagedGlobalNDCZ = UnpackFloat32FromUint32(averagedAtomicData);
        if (!(averagedGlobalNDCZ < 1)) {
            return;
        }
        const vec2 averagedScreenUV = UVFromCoord(averagedScreenCoord, averagedScreenSize);
        const vec2 averagedScreenNDC = NDCFromUV(averagedScreenUV);
        const vec4 averagedGlobalClipPos = ClipPosFromNDC(averagedScreenNDC, averagedGlobalNDCZ);
        averagedWorldPos[i] = WorldPosFromGlobalClipPos(averagedGlobalClipPos);
    }

    vec3 xDiff = averagedWorldPos[1] - averagedWorldPos[0];
    vec3 yDiff = topTriangle ? averagedWorldPos[0] - averagedWorldPos[2] : averagedWorldPos[2] - averagedWorldPos[0];
    vec3 normal = normalize(cross(xDiff, yDiff));

//    const ivec2 averagedScreenCoord = ivec2(gl_GlobalInvocationID.xy / LOCAL_SIZE);
//    const vec2 averagedScreenUV = UVFromCoord(averagedScreenCoord, iAveragedScreenSize);
//    const vec2 averagedScreenNDC = NDCFromUV(averagedScreenUV);
//    const uint averagedAtomicData = imageLoad(outputAveragedAtomic, averagedScreenCoord).r;
//    const float averagedGlobalNDCZ = UnpackFloat32FromUint32(averagedAtomicData);
//    const vec4 averagedGlobalClipPos = ClipPosFromNDC(averagedScreenNDC, averagedGlobalNDCZ);
//    const vec3 averagedWorldPos = WorldPosFromGlobalClipPos(averagedGlobalClipPos);
//    if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0 && gl_WorkGroupID.x == 22 && gl_WorkGroupID.y == 16) {
////        debugPrintfEXT("mai %d %d %d %f %f %f",gl_WorkGroupID.x, averagedScreenCoord.x, averagedScreenCoord.y, averagedWorldPos.x, averagedWorldPos.y, averagedWorldPos.z);
//    }
//    if (gl_WorkGroupID.x == 22 && gl_WorkGroupID.y == 16) {
//        WriteDebugWorldPos(averagedWorldPos, screenCoord);
//    }

    nodeOriginWorldPos = averagedWorldPos[0];
    nodeOriginWorldDirection = normal;

    // calc source pixel
    vec3 intersectNodeNDC;
    vec3 depthProjectedGlobalNDC;
    if (!NodeIntersect(screenUV, intersectNodeNDC, depthProjectedGlobalNDC)) {
        return;
    }
    const vec2 intersectNodeUV = UVFromNDC(intersectNodeNDC);
    const vec2 depthProjectedGlobalUV = UVFromNDC(depthProjectedGlobalNDC);
    const ivec2 depthProjectedGlobalCoord = CoordFromUV(depthProjectedGlobalUV, screenSize);

    // write source pixel
    const vec4 color = texture(nodeColorTexture, intersectNodeUV);
    const uint packedData = packFloatAnd565Color(depthProjectedGlobalNDC.z, color.xyz);
    writeAtomicData(depthProjectedGlobalCoord, packedData);
    //        writeAtomicData(screenCoord, packedData);

//    if (topTriangle){
//        for (int i = 0; i < 3; ++i) {
//            const ivec2 averagedScreenCoord = ivec2(19, 13) + averagedOffsets[i];
//            const vec2 averagedScreenUV = UVFromCoord(averagedScreenCoord, averagedScreenSize);
//            vec3 intersectNodeNDC2;
//            vec3 depthProjectedGlobalNDC2;
//            if (!NodeIntersect(averagedScreenUV, intersectNodeNDC2, depthProjectedGlobalNDC2)) {
//            }
//            vec4 clip2 = ClipPosFromNDC(depthProjectedGlobalNDC2);
//            WriteDebugWorldPos(WorldPosFromGlobalClipPos(clip2), screenCoord);
//        }
//    }


//    if (gl_WorkGroupID.x == 19 && gl_WorkGroupID.y == 13 && topTriangle) {
//        if (gl_LocalInvocationID.x == 16 && gl_LocalInvocationID.y == 16) {
//            //            debugPrintfEXT("0 %f %f %f", xDiff.x, xDiff.y, xDiff.z);
//            //            debugPrintfEXT("1 %f %f %f", yDiff.x, yDiff.y, yDiff.z);
//            //            debugPrintfEXT("2 %f %f %f", normal.x, normal.y, normal.z);
//        }
//
//
//        WriteDebugWorldPos(averagedProjectedWorldPosDebug[0], screenCoord);
//        WriteDebugWorldPos(averagedProjectedWorldPosDebug[1], screenCoord);
//        WriteDebugWorldPos(averagedProjectedWorldPosDebug[2], screenCoord);
//
//        //        vec3 mid = mix(averagedWorldPos[0], averagedWorldPos[1], .5);
//        //        WriteDebugLine(mid, mid + normal * 0.25, screenCoord);
//    }

    // Stepback
    //    const vec3 intersectGlobalNDC = GlobalNDCFromNodeNDC(intersectNodeNDC);
    //    const vec2 intersectGlobalUV = UVFromNDC(intersectGlobalNDC);
    //    const vec2 stepBackDir = depthProjectedGlobalUV - intersectGlobalUV;
    //    vec2 normalizedStepBackDir;
    //    bool stepBackDirIsX;
    //    XYCoordNormalizedDir(stepBackDir, stepBackDirIsX, normalizedStepBackDir);
    //    const ivec2 stepBackCoord = iRound(normalizedStepBackDir + vec2(screenCoord));
    //    const vec2 stepBackUV = UVFromCoord(stepBackCoord, screenSize);
    //    vec3 stepbackIntersectNodeNDC;
    //    vec3 stepbackDepthProjectedGlobalNDC;
    //    if (!NodeIntersect(stepBackUV, stepbackIntersectNodeNDC, stepbackDepthProjectedGlobalNDC)) {
    //        return;
    //    }
    //
    //    const vec2 stepbackDepthProjectedGlobalUV = UVFromNDC(stepbackDepthProjectedGlobalNDC);
    //    const ivec2 stepbackDepthProjectedGlobalCoord = CoordFromUV(stepbackDepthProjectedGlobalUV, screenSize);
    //    const ivec2 stepBackCoordDiff = abs(stepbackDepthProjectedGlobalCoord - depthProjectedGlobalCoord) - 1;
    //    const int stepbackCount = clamp((stepBackDirIsX ? stepBackCoordDiff.x : stepBackCoordDiff.y), 1, 10);
    //    vec2 currentCoord = depthProjectedGlobalCoord;
    //    ivec2 roundedCoord = depthProjectedGlobalCoord;
    //    for (int step = 0; step < stepbackCount; ++step){
    //        currentCoord += normalizedStepBackDir;
    //        roundedCoord = iRound(currentCoord);
    //        writeAtomicData(roundedCoord, packedData);
    //    }
}

void mainTiled()
{
    const uint tileIndex = gl_WorkGroupID.x;

    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);

    const vec2 uvSize = 1.0 / screenSize;
    const vec2 uvHalfSize = 0.5 / screenSize;
    //    const float uvHalfSize = 0.0;

    uvec2 ulTileCoord;
    UnpackU16U16FromU32(tileBuffer.tiles[tileIndex].upperLeftXU16YU16, ulTileCoord.x, ulTileCoord.y);
    uvec2 lrTileCoord;
    UnpackU16U16FromU32(tileBuffer.tiles[tileIndex].lowerRightXU16YU16, lrTileCoord.x, lrTileCoord.y);
    float tileGlobalNDCZ;
    uint tileId;
    UnpackFloat24Uint8FromUint32(tileBuffer.tiles[tileIndex].depthF24IDU8, tileGlobalNDCZ, tileId);

    const vec2 lrTileUV = UVFromCoord(ulTileCoord, iScreenSize);
    const vec2 ulTileUV = UVFromCoord(lrTileCoord, iScreenSize);
    const vec2 ulTileNDC = NDCFromUV(ulTileUV);
    const vec4 ulClipPos = ClipPosFromNDC(ulTileNDC, tileGlobalNDCZ);
    const vec3 ulTileWorldPos = WorldPosFromGlobalClipPos(ulClipPos);

    nodeOriginWorldPos = ulTileWorldPos;

    const uvec2 screenCoord = ulTileCoord + ivec2(gl_LocalInvocationID.xy);
    if (screenCoord.x >= lrTileCoord.x || screenCoord.y >= lrTileCoord.y) {
        return;
    }

    const vec2 screenUV = UVFromCoord(screenCoord, screenSize);
    const vec2 screenNDC = NDCFromUV(screenUV);

    //    WriteDebugWorldPos(vec3(.5, .5, -.5), screenCoord);
    //    WriteDebugWorldPos(vec3(-.5, .5, -.5), screenCoord);
    //    WriteDebugWorldPos(vec3(-.5, -.5, -.5), screenCoord);
    //    WriteDebugWorldPos(vec3(.5, -.5, -.5), screenCoord);

    //    WriteDebugUV(ulTileUV, screenCoord);
    //    WriteDebugUV(lrTileUV, screenCoord);

    // calc source pixel
    vec3 intersectNodeNDC;
    vec3 depthProjectedGlobalNDC;
    if (!NodeIntersect(screenUV, intersectNodeNDC, depthProjectedGlobalNDC)) {
        return;
    }
    const vec2 intersectNodeUV = UVFromNDC(intersectNodeNDC);
    const vec2 depthProjectedGlobalUV = UVFromNDC(depthProjectedGlobalNDC);
    const ivec2 depthProjectedGlobalCoord = CoordFromUV(depthProjectedGlobalUV, screenSize);

    // write source pixel
    const vec4 color = texture(nodeColorTexture, intersectNodeUV);
    const uint packedData = packFloatAnd565Color(depthProjectedGlobalNDC.z, color.xyz);
    const uint packedDatar = packFloatAnd565Color(depthProjectedGlobalNDC.z, vec3(1, 0, 1));
    const uint packedDatag = packFloatAnd565Color(depthProjectedGlobalNDC.z, vec3(0, 1, 0));
    //    if (gl_LocalInvocationID.x == 31 && gl_GlobalInvocationID.y % 2 == 0) {
    //        writeAtomicData(depthProjectedGlobalCoord, packedDatar);
    //    } else if (gl_LocalInvocationID.x == 0 && gl_GlobalInvocationID.y % 2 == 1) {
    //        writeAtomicData(depthProjectedGlobalCoord, packedDatag);
    //    } else {
    writeAtomicData(depthProjectedGlobalCoord, packedData);
    //    }

    //            writeAtomicData(screenCoord, packedData);

    // Stepback
    //    const vec3 intersectGlobalNDC = GlobalNDCFromNodeNDC(intersectNodeNDC);
    //    const vec2 intersectGlobalUV = UVFromNDC(intersectGlobalNDC);
    //    const vec2 stepBackDir = depthProjectedGlobalUV - intersectGlobalUV;
    //    vec2 normalizedStepBackDir;
    //    bool stepBackDirIsX;
    //    XYCoordNormalizedDir(stepBackDir, stepBackDirIsX, normalizedStepBackDir);
    //    const ivec2 stepBackCoord = iRound(normalizedStepBackDir + vec2(screenCoord));
    //    const vec2 stepBackUV = UVFromCoord(stepBackCoord, screenSize);
    //    vec3 stepbackIntersectNodeNDC;
    //    vec3 stepbackDepthProjectedGlobalNDC;
    //    if (!NodeIntersect(stepBackUV, stepbackIntersectNodeNDC, stepbackDepthProjectedGlobalNDC)) {
    //        return;
    //    }
    //
    //    const vec2 stepbackDepthProjectedGlobalUV = UVFromNDC(stepbackDepthProjectedGlobalNDC);
    //    const ivec2 stepbackDepthProjectedGlobalCoord = CoordFromUV(stepbackDepthProjectedGlobalUV, screenSize);
    //    const ivec2 stepBackCoordDiff = abs(stepbackDepthProjectedGlobalCoord - depthProjectedGlobalCoord) - 1;
    //    const int stepbackCount = clamp((stepBackDirIsX ? stepBackCoordDiff.x : stepBackCoordDiff.y), 1, 10);
    //    vec2 currentCoord = depthProjectedGlobalCoord;
    //    ivec2 roundedCoord = depthProjectedGlobalCoord;
    //    for (int step = 0; step < stepbackCount; ++step){
    //        currentCoord += normalizedStepBackDir;
    //        roundedCoord = iRound(currentCoord);
    //        writeAtomicData(roundedCoord, packedData);
    //    }
}
