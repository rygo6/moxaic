#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

vec3 intersectRayPlane(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal) {
    const float facingRatio = dot(planeNormal, rayDir);
    const float t = dot(planePoint - rayOrigin, planeNormal) / facingRatio;
    return (facingRatio < 0) ? (rayOrigin + t * rayDir) : vec3(0, 0, 0);
}

vec3 GlobalClipPosToWorldPos(vec4 clipPos)
{
    const vec4 worldPos = globalUBO.invView * globalUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec3 GlobalNDCRay(vec2 ndc)
{
    const vec4 clipRayDir = vec4(ndc, 1, 1);
    const vec4 viewSpace = globalUBO.invProj * clipRayDir;
    const vec4 viewDir = vec4(viewSpace.xy, 1, 0);
    const vec3 globalWorldRayDir = normalize((globalUBO.invView * viewDir).xyz);
    return globalWorldRayDir;
}

vec4 GlobalClipPosFromWorldPos(vec3 worldPos)
{
    return globalUBO.proj * globalUBO.view * vec4(worldPos, 1);
}

vec3 NodeClipPosToWorldPos(vec4 clipPos)
{
    const vec4 worldPos = nodeUBO.invView * nodeUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec4 NodeClipPosFromWorldPos(vec3 worldPos)
{
    return nodeUBO.proj * nodeUBO.view * vec4(worldPos, 1);
}

vec3 NDCFromClipPos(vec4 clipPos)
{
    return clipPos.xyz / clipPos.w;
}

vec2 UVToNDC(vec2 uv)
{
    return vec2(vec2(1, -1) * (uv * 2 - 1));;
}

vec2 UVFromNDC(vec3 ndc)
{
    return (vec2((vec2(1, -1) * ndc.xy) + 1) * 0.5);
}

ivec2 CoordFromUV(vec2 uv, vec2 screenSize)
{
    return ivec2(round(uv * screenSize));
}

vec2 CoordToUV(ivec2 coord, vec2 screenSize)
{
    return vec2(coord) / screenSize;
}

void NodeIntersetUV(const vec2 uv, out vec2 nodeUV, out vec2 outputUV)
{
    const vec2 ndc = UVToNDC(uv);
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldClipPos = GlobalClipPosToWorldPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);

    const vec3 nodeOriginWorldPos = vec3(0, 0, 0);
    const vec3 nodeOriginWorldDirection = vec3(0, 0, 1);// -1 face towards view
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldClipPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);

    const float depth = texture(nodeDepth, nodeIntersectUV).r;

    const vec4 nodeQuadClipPos = vec4(nodeIntersectNDC.xy, depth, 1);
    const vec3 nodeQuadWorldPos = NodeClipPosToWorldPos(nodeQuadClipPos);

    const vec4 newClipPos = GlobalClipPosFromWorldPos(nodeQuadWorldPos);
    const vec3 newNDC = NDCFromClipPos(newClipPos);
    const vec2 newUV = UVFromNDC(newNDC);

    nodeUV = nodeIntersectUV;
    outputUV = newUV;
}

const int offsetCount = 4;
const ivec2 coordOffsets[offsetCount] = { { 0, 0 }, { 1, 0 }, { 1, 1 }, { 0, 1 } };

void main()
{
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec2 nodeUVs[offsetCount];
    vec2 outputUVs[offsetCount];
    for (int i = 0; i < offsetCount; ++i){
        const vec2 uv = CoordToUV(coord + coordOffsets[i], screenSize);
        vec2 ulnodeUV, uloutputUV;
        NodeIntersetUV(uv, nodeUVs[i], outputUVs[i]);
    }

    const vec4 color = texture(nodeColor, nodeUVs[0]);
    const vec3 colorSRGB = pow(color.rgb, vec3(1.0 / 2.2));

    const ivec2 outputCoord = CoordFromUV(outputUVs[0], screenSize);
    imageStore(outputColor, outputCoord, vec4(colorSRGB, color.a));
}
