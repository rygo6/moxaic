#version 450
#extension GL_EXT_debug_printf : enable

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

#define MXC_CAMERA_MIN_Z 0.0001f

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 5, r32ui) uniform readonly uimage2DMS outputAveragedAtomic;
layout (set = 1, binding = 6, r32ui) uniform uimage2D outputAtomic;
//layout (set = 1, binding = 7) uniform writeonly image2D outputColor;

vec3 nodeOriginWorldPos = vec3(0, 0, 0);
vec3 nodeOriginWorldDirection = vec3(0, 0, -1);

bool NodeIntersectUV(const vec2 uv, out vec2 nodeUV, out vec3 nodeWorldNormal, out vec3 stepNormalNDC, out vec3 depthProjectedNDC)
{
    const vec2 ndc = NDCFromUV(1 - uv);// why do I 1 - uv here?! It does flip it to proper layout
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);
    nodeUV = nodeIntersectUV;

    nodeWorldNormal = texture(nodeNormalTexture, nodeIntersectUV).xyz * vec3(1, -1, 1);// I encoded y = up on sphere normals
    const float nodeDepthSample = texture(nodeDepthTexture, nodeIntersectUV).r;

    if (nodeIntersectUV.x < 0
    || nodeIntersectUV.x > 1
    || nodeIntersectUV.y < 0
    || nodeIntersectUV.y > 1
    || nodeDepthSample > .99
    //    || dot(nodeWorldNormal.xyz, globalWorldRay) < 0
    ) {
        return false;
    }

    const vec4 nodeQuadDepthClipPos = vec4(nodeIntersectNDC.xy, nodeDepthSample, 1);
    const vec3 nodeQuadDepthWorldPos = WorldPosFromNodeClipPos(nodeQuadDepthClipPos);
    const vec4 nodeQuadDepthProjectedClipPos = GlobalClipPosFromWorldPos(nodeQuadDepthWorldPos);
    const vec3 nodeQuadDepthProjectedNDC = NDCFromClipPos(nodeQuadDepthProjectedClipPos);
    depthProjectedNDC = nodeQuadDepthProjectedNDC;

    const vec3 stepNormalWorldPos = nodeQuadDepthWorldPos + (nodeWorldNormal * 0.1);
    const vec4 stepNormalClipPos = GlobalClipPosFromWorldPos(stepNormalWorldPos);
    stepNormalNDC = NDCFromClipPos(stepNormalClipPos);

    return true;
}

void writeAtomicData(ivec2 coord, uint data){
    imageAtomicMin(outputAtomic, coord, data);
}

uint packFloatAnd565Color(float normalizedDepth, vec3 color) {
    uint packedValue = uint(normalizedDepth * 65535.0);

    uint r = uint(color.r * 31.0);
    uint g = uint(color.g * 63.0);
    uint b = uint(color.b * 31.0);
    uint packedColor = (r << 11) | (g << 5) | b;

    return (packedValue << 16) | packedColor;
}

void WriteDebugCoord(ivec2 debugCoord){
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const ivec2 diff = coord - debugCoord;
    if (dot(diff, diff) < 100){
        const uint packedData = packFloatAnd565Color(0, vec3(0, 1, 1));
        writeAtomicData(coord, packedData);
    }
}

void WriteDebugUV(vec2 debugUV){
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const ivec2 debugCoord = CoordFromUV(debugUV, screenSize);
    WriteDebugCoord(debugCoord);
}

void WriteDebugNDC(vec3 ndc){
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv);
}

void WriteDebugWorldPos(vec3 debugWorldPos){
    const vec4 clipPos = GlobalClipPosFromWorldPos(debugWorldPos);
    const vec3 ndc = NDCFromClipPos(clipPos);
    const vec2 uv = UVFromNDC(ndc);
    WriteDebugUV(uv);
}

float inverseLerp(float value, float a, float b) {
    return a == b ? 0 : (value - a) / (b - a);
}

vec3 GlobalNDCFromNodeNDC(vec3 nodeNDC){
    const vec3 worldPos = WorldPosFromNodeClipPos(vec4(nodeNDC, 1));
    const vec4 globalClipPos = GlobalClipPosFromWorldPos(worldPos.xyz);
    const vec3 globalNDC = NDCFromClipPos(globalClipPos);
    return globalNDC;
}

float areaOfQuadrilateral(vec2 a, vec2 b, vec2 c, vec2 d) {
    return 0.5 * abs(
    a.x * b.y + b.x * c.y + c.x * d.y + d.x * a.y -
    (b.x * a.y + c.x * b.y + d.x * c.y + a.x * d.y)
    );
}

float areaOfQuadrilateral(vec2 verts[4]) {
    return areaOfQuadrilateral(verts[0], verts[1], verts[2], verts[3]);
}

float SqrMag(vec2 values[2]) {
    const  vec2 diff = values[0] - values[1];
    return dot(diff, diff);
}

const int ndcCornerCount = 2;
const vec2 ndcCorners[] = {
{ -1, 1 },
{ 1, -1 },
};

float CalcNodeZPlane(){

    vec2 uvs[ndcCornerCount];
    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 0));
        if (ndc.z < 0) {
            return 1;// maybe -z?
        }
        uvs[i] = UVFromNDC(ndc);
    }
    const float frontMag = SqrMag(uvs);

    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 1));
        uvs[i] = UVFromNDC(ndc);
    }
    const float backMag = SqrMag(uvs);

    float nodeZPlane = frontMag < backMag ? 1 : -1;
    if (abs(frontMag - backMag) < .1) {
        nodeZPlane = -1;
    }

    return nodeZPlane;
}

void XYCoordNormalizedDir(const vec2 dir, out bool isXDir, out vec2 normalizedDir){
    const vec2 absDir = abs(dir);
    isXDir = absDir.x > absDir.y;
    const vec2 xNormalizedDir = dir * (1.0f / absDir.x);
    const vec2 yNormalizedDir = dir * (1.0f / absDir.y);
    normalizedDir = (isXDir ? xNormalizedDir : yNormalizedDir);
}

void Unpack16F8F8FFromUint(uint packed, out float float1, out float float2, out float float3) {
    uint int1 = (packed >> 16) & 0xFFFFu;// Extract first 16 bits
    uint int2 = (packed >> 8) & 0xFFu;// Extract next 8 bits
    uint int3 = packed & 0xFFu;// Extract last 8 bits

    // Normalize each component back to [0, 1] range
    float1 = float(int1) / 65535.0;
    float2 = float(int2) / 255.0;
    float3 = float(int3) / 255.0;
}

uint PackUintFromVec3(vec3 v) {
    uint r = uint(v.r * 255.0);
    uint g = uint(v.g * 255.0);
    uint b = uint(v.b * 255.0);
    return (r << 16) | (g << 8) | b;
}

vec3 UnpackVec3FromUint(uint packed) {
    uint r = (packed >> 16) & 0xFFu;
    uint g = (packed >> 8) & 0xFFu;
    uint b = packed & 0xFFu;
    return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);
}

float UnpackFloatFromUint(uint packed) {
    float value = float(packed);
    return value / 4294967295.0;
}

bool NodeWorldPosFromCoord(const ivec2 coord, vec2 screenSize, out vec3 worldPos) {
    const vec2 uv = UVFromCoord(coord, screenSize);
    const vec2 ndc = NDCFromUV(uv);
    const uint nodeData = imageLoad(outputAveragedAtomic, coord, 0).r;
    const float nodeZ = UnpackFloatFromUint(nodeData);
    if (nodeZ > .99) {
        return false;
    }
    const vec4 globalClipPos = vec4(ndc, nodeZ, 1);
    worldPos = WorldPosFromGlobalClipPos(globalClipPos);
    return true;
}

const int sampleCount = 4;
const ivec2 samplesOffsets[] = { { 0, 0 }, { 1, 0 }, { 1, 1 }, { 0, 1 }, };

void main()
{
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = UVFromCoord(coord, screenSize);
    const vec2 ndc = NDCFromUV(uv);

    const vec2 uvStepSize = UVFromCoord(coord + 1, screenSize) - uv;

    const ivec2 iAveragedScreenSize = ivec2(globalUBO.width / LOCAL_SIZE, globalUBO.height / LOCAL_SIZE);
    const vec2 averagedScreenSize = vec2(iAveragedScreenSize);
    const ivec2 averagedCoord = CoordFromUV(uv, averagedScreenSize);

    nodeOriginWorldPos = vec3(0, 0, 0);
    nodeOriginWorldDirection = vec3(0, 0, -1);

    // calc source pixel
    vec2 nodeUV;
    vec3 worldNormal;
    vec3 stepNormalNDC;
    vec3 depthProjectedNDC;
    if (!NodeIntersectUV(uv, nodeUV, worldNormal, stepNormalNDC, depthProjectedNDC)) {
        //        return;
    }

    // write source pixel
    const vec4 color = texture(nodeColorTexture, nodeUV);
    const uint packedData = packFloatAnd565Color(depthProjectedNDC.z, color.xyz);
    const vec2 depthProjectUV = UVFromNDC(depthProjectedNDC);
    const ivec2 depthProjectedCoord = CoordFromUV(depthProjectUV, screenSize);
    //    writeAtomicData(depthProjectedCoord, packedData);
//        writeAtomicData(coord, packedData);


    vec3 averagedNodeWorldPos;
    if (!NodeWorldPosFromCoord(averagedCoord, averagedScreenSize, averagedNodeWorldPos)){
        return;
    }

    bool crossFail = false;
    vec3 rAveragedNodeWorldPos;
    if (!NodeWorldPosFromCoord(averagedCoord + ivec2(1, 0), averagedScreenSize, rAveragedNodeWorldPos)){
        rAveragedNodeWorldPos = averagedNodeWorldPos + vec3(1, 0, 0);
        crossFail = true;
    }
    vec3 lAveragedNodeWorldPos;
    if (!NodeWorldPosFromCoord(averagedCoord + ivec2(0, 1), averagedScreenSize, lAveragedNodeWorldPos)){
        lAveragedNodeWorldPos = averagedNodeWorldPos + vec3(0, 1, 0);
        crossFail = true;
    }

    if (averagedCoord.x == 16 && averagedCoord.y == 16){
        WriteDebugWorldPos(averagedNodeWorldPos);
        WriteDebugWorldPos(rAveragedNodeWorldPos);
        WriteDebugWorldPos(lAveragedNodeWorldPos);
    }

    const vec3 averagedNodeWorldDirRight = normalize(averagedNodeWorldPos - rAveragedNodeWorldPos);
//    const vec3 averagedNodeWorldDirUp = normalize(averagedNodeWorldPos - lAveragedNodeWorldPos);
    const vec3 averagedNodeWorldDirUp = vec3(0,-1,0);
    const vec3 averagedNodeWorldDirForward = cross(averagedNodeWorldDirRight, averagedNodeWorldDirUp);

    nodeOriginWorldPos = averagedNodeWorldPos;
//    nodeOriginWorldDirection = averagedNodeWorldDirForward;
    if (crossFail){
        nodeOriginWorldDirection = vec3(0, 0, -1);;
    }

    //    if (gl_GlobalInvocationID.x == 520 && gl_GlobalInvocationID.y == 520) {
    //        vec3 log = rAveragedNodeWorldPos;
    //        debugPrintfEXT("%f | %f | %f", log.x, log.y, log.z);
    //    }

    vec2 nodeUV2;
    vec3 worldNormal2;
    vec3 stepNormalNDC2;
    vec3 depthProjectedNDC2;
    if (!NodeIntersectUV(uv, nodeUV2, worldNormal2, stepNormalNDC2, depthProjectedNDC2)) {
        return;
    }
    const vec4 color2 = texture(nodeColorTexture, nodeUV2);
    const vec2 depthProjectUV2 = UVFromNDC(depthProjectedNDC2);
    const ivec2 depthProjectedCoord2 = CoordFromUV(depthProjectUV2, screenSize);
    const uint debugPackedData = packFloatAnd565Color(0, vec3(color2.x, 0, 0));
    writeAtomicData(depthProjectedCoord2, debugPackedData);
    const uint debugPackedData2 = packFloatAnd565Color(1, vec3(0, color2.y, 0));
    writeAtomicData(coord, debugPackedData2);


    // calc and write step normal pixel
    //    const vec2 stepNormalUV = UVFromNDC(stepNormalNDC);
    //    const vec2 stepNormalDir = stepNormalUV - uv;
    ////    const ivec2 stepNormalCoord = CoordFromUV(stepNormalUV, screenSize);
    //    vec2 normalizedStepNormalDir;
    //    bool stepNormalDirIsX;
    //    XYCoordNormalizedDir(stepNormalDir, stepNormalDirIsX, normalizedStepNormalDir);
    //    const ivec2 stepNormalCoord = iRound(normalizedStepNormalDir + vec2(depthProjectedCoord));
    //    writeAtomicData(stepNormalCoord, packedData);
    //    const ivec2 stepNormalCoord2 = iRound(2.0 * normalizedStepNormalDir + vec2(depthProjectedCoord));
    //    writeAtomicData(stepNormalCoord2, packedData);

    // calc stepback
    //    const vec2 stepBackDir = depthProjectUV - uv;
    //    vec2 normalizedStepBackDir;
    //    bool stepBackDirIsX;
    //    XYCoordNormalizedDir(stepBackDir, stepBackDirIsX, normalizedStepBackDir);
    //    const ivec2 stepBackCoord = iRound(normalizedStepBackDir + vec2(coord));
    //    const vec2 stepBackUV = uvFromCoord(stepBackCoord, screenSize);
    //    vec2 stepBackNodeUV;
    //    vec3 stepBackStepNormalNDC;
    //    vec3 stepBackProjectedNDC;
    //    if (!NodeIntersectUV(stepBackUV, stepBackNodeUV, stepBackStepNormalNDC, stepBackProjectedNDC)) {
    //        return;
    //    }

    // write stepback pixels
    //    const vec2 stepbackProjectedUV = UVFromNDC(stepBackProjectedNDC);
    //    const ivec2 stepbackOutputUVCoord = CoordFromUV(stepbackProjectedUV, screenSize);
    //    const ivec2 stepBackCoordDiff = abs(stepbackOutputUVCoord - depthProjectedCoord);
    //    const int stepbackCount = clamp((stepBackDirIsX ? stepBackCoordDiff.x : stepBackCoordDiff.y) - 1, 0, 4);// -1 so it doesn't overlap end pixel in stepback
    //    vec2 currentCoord = depthProjectedCoord;
    //    ivec2 roundedCoord = depthProjectedCoord;
    //    for (int step = 0; step < stepbackCount; ++step){
    //        currentCoord += normalizedStepBackDir;
    //        roundedCoord = iRound(currentCoord);
    //        writeAtomicData(roundedCoord, packedData);
    //    }
}
