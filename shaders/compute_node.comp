#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct MeshTaskPayload
{
    vec4 ulClipPos, urClipPos, lrClipPos, llClipPos;
    vec3 ulNDC, urNDC, lrNDC, llNDC;
};

MeshTaskPayload payload;

// https://jcgt.org/published/0011/03/04/paper-lowres.pdf
float area(vec2 a, vec2 b) { return (a.x*b.y)-(a.y*b.x); }
vec2 barycentricQuadUV(vec2 ndc) {
    const float w[4] = { payload.ulClipPos.w, payload.urClipPos.w, payload.lrClipPos.w, payload.llClipPos.w };
    const vec2 v[4] = { payload.ulNDC.xy, payload.urNDC.xy, payload.lrNDC.xy, payload.llNDC.xy };
    float r[4], t[4], u[4], f[4];
    vec2 s[4];
    for (int i = 0; i < 4; i++) {
        s[i] = v[i] - ndc;
        r[i] = length(s[i]) * sign(w[i]);
    }
    for (int i = 0; i < 4; i++) {
        float A = area(s[i], s[(i + 1) % 4]);
        float D = dot(s[i], s[(i + 1) % 4]);
        t[i] = (r[i] * r[(i + 1) % 4] - D) / A;
    }
    for (int i = 0; i < 4; i++) {
        u[i] = (t[(i + 3) % 4] + t[i]) / r[i];
    }
    const vec4 wt = vec4(u[0], u[1], u[2], u[3]) / (u[0] + u[1] + u[2] + u[3]);
    for (int i = 0; i < 4; i++) {
        f[i] =  wt[i] / w[i];
    }
    const vec2 ulUV = vec2(0, 1), urUV = vec2(1, 1), lrUV = vec2(1, 0), llUV = vec2(0, 0);
    return (f[0] * ulUV + f[1] * urUV + f[2] * lrUV + f[3] * llUV) / (f[0] + f[1] + f[2] + f[3]);
}

vec4 toNodeWorldPos(vec4 clipPos)
{
    vec4 worldPos = nodeUBO.invView * nodeUBO.invProj * clipPos;
    return worldPos;
}

vec2 toNDC(vec2 uv)
{
    return vec2(vec2(1, -1) * (uv * 2 - 1));;
}

vec2 toUV(vec3 ndc)
{
//    return (ndc.xy / vec2(1, -1) + 1) / 2;
    return (vec2((vec2(1, -1) * ndc.xy) + 1) * 0.5);
}

void main()
{


    const vec4 nodeOriginClipPos = nodeUBO.proj * nodeUBO.view * vec4(0, 0, 0, 1);
    const vec4 ulWorldPos = toNodeWorldPos(vec4(-nodeOriginClipPos.w, nodeOriginClipPos.w, nodeOriginClipPos.z, nodeOriginClipPos.w));
    const vec4 urWorldPos = toNodeWorldPos(vec4(nodeOriginClipPos.w, nodeOriginClipPos.w, nodeOriginClipPos.z, nodeOriginClipPos.w));
    const vec4 lrWorldPos = toNodeWorldPos(vec4(nodeOriginClipPos.w, -nodeOriginClipPos.w, nodeOriginClipPos.z, nodeOriginClipPos.w));
    const vec4 llWorldPos = toNodeWorldPos(vec4(-nodeOriginClipPos.w, -nodeOriginClipPos.w, nodeOriginClipPos.z, nodeOriginClipPos.w));
    payload.ulClipPos = globalUBO.proj * globalUBO.view * ulWorldPos;
    payload.urClipPos = globalUBO.proj * globalUBO.view * urWorldPos;
    payload.lrClipPos = globalUBO.proj * globalUBO.view * lrWorldPos;
    payload.llClipPos = globalUBO.proj * globalUBO.view * llWorldPos;
    payload.ulNDC = payload.ulClipPos.xyz / payload.ulClipPos.w;
    payload.urNDC = payload.urClipPos.xyz / payload.urClipPos.w;
    payload.lrNDC = payload.lrClipPos.xyz / payload.lrClipPos.w;
    payload.llNDC = payload.llClipPos.xyz / payload.llClipPos.w;

    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    // honestly dont quite understand why this revcoord is needed compared to mesh shader
    const ivec2 revCoord = ivec2(globalUBO.width - coord.x, coord.y);
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    const vec2 uv = vec2(revCoord) / screenSize;
    const vec2 ndc = toNDC(uv);

    //    vec4 originClip = globalUBO.proj * globalUBO.view * nodeOriginClipPos;
    //    vec3 originNDC = originClip.xyz / originClip.w;
    //    vec2 origin = originNDC.xy - ndc;
    //    if (dot(origin, origin) < .001){
    //        imageStore(outputColor, coord, vec4(0, 0, 1, 1));
    //        return;
    //    }
    //    vec2 UL = payload.ulNDC.xy - ndc;
    //    if (dot(UL, UL) < .001){
    //        imageStore(outputColor, coord, vec4(0, 1, 0, 1));
    //        return;
    //    }
    //    vec2 UR = payload.urNDC.xy - ndc;
    //    if (dot(UR, UR) < .001){
    //        imageStore(outputColor, coord, vec4(1, 0, 0, 1));
    //        return;
    //    }
    //    vec2 LL = payload.llNDC.xy - ndc;
    //    if (dot(LL, LL) < .001){
    //        imageStore(outputColor, coord, vec4(0, 1, 0, 1));
    //        return;
    //    }
    //    vec2 LR = payload.lrNDC.xy - ndc;
    //    if (dot(LR, LR) < .001){
    //        imageStore(outputColor, coord, vec4(1, 0, 0, 1));
    //        return;
    //    }

    const vec2 nodeQuadUV = barycentricQuadUV(ndc);
    //    const ivec2 inQuadCoord = ivec2(round(inQuadUv * screenSize));

    const vec4 color = texture(nodeColor, nodeQuadUV);
    const vec4 normal = texture(nodeNormal, nodeQuadUV);
    const vec4 gBuffer = texture(nodeGBuffer, nodeQuadUV);
    const float depth = texture(nodeDepth, nodeQuadUV).r;

    const vec3 sRGB = pow(color.rgb, vec3(1.0 / 2.2));

    vec2 nodeQuadNDC = toNDC(nodeQuadUV);
    vec4 nodeQuadClipPos = vec4(nodeQuadNDC.xy, depth, 1);
    vec4 nodeQuadWorldPos = toNodeWorldPos(nodeQuadClipPos);

    const vec4 newClipPos = globalUBO.proj * globalUBO.view * nodeQuadWorldPos;
    const vec3 newNDC = newClipPos.xyz / newClipPos.w;
    const vec2 newUV = toUV(newNDC);
    const ivec2 newCoord = ivec2(round(newUV * screenSize));

    imageStore(outputColor, newCoord, vec4(sRGB, 1));
    //    imageStore(outputColor, newCoord + ivec2(0, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(-1, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, -1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(0, -1), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, -1), color);
}
