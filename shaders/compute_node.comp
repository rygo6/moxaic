#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

struct MeshTaskPayload
{
    vec4 ulClipPos, urClipPos, lrClipPos, llClipPos;
    vec3 ulNDC, urNDC, lrNDC, llNDC;
};

MeshTaskPayload payload;

vec3 intersectRayPlane(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal) {
    float facingRatio = dot(planeNormal, rayDir);
    float t = dot(planePoint - rayOrigin, planeNormal) / facingRatio;
    return (facingRatio < 0) ? (rayOrigin + t * rayDir) : vec3(0, 0, 0);
}

// https://jcgt.org/published/0011/03/04/paper-lowres.pdf
float area(vec2 a, vec2 b) { return (a.x*b.y)-(a.y*b.x); }
vec2 barycentricQuadUV(vec2 ndc) {
    const float w[4] = { payload.ulClipPos.w, payload.urClipPos.w, payload.lrClipPos.w, payload.llClipPos.w };
    const vec2 v[4] = { payload.ulNDC.xy, payload.urNDC.xy, payload.lrNDC.xy, payload.llNDC.xy };
    float r[4], t[4], u[4], f[4];
    vec2 s[4];
    for (int i = 0; i < 4; i++) {
        s[i] = v[i] - ndc;
        r[i] = length(s[i]) * sign(w[i]);
    }
    for (int i = 0; i < 4; i++) {
        float A = area(s[i], s[(i + 1) % 4]);
        float D = dot(s[i], s[(i + 1) % 4]);
        t[i] = (r[i] * r[(i + 1) % 4] - D) / A;
    }
    for (int i = 0; i < 4; i++) {
        u[i] = (t[(i + 3) % 4] + t[i]) / r[i];
    }
    const vec4 wt = vec4(u[0], u[1], u[2], u[3]) / (u[0] + u[1] + u[2] + u[3]);
    for (int i = 0; i < 4; i++) {
        f[i] =  wt[i] / w[i];
    }
    const vec2 ulUV = vec2(0, 1), urUV = vec2(1, 1), lrUV = vec2(1, 0), llUV = vec2(0, 0);
    return (f[0] * ulUV + f[1] * urUV + f[2] * lrUV + f[3] * llUV) / (f[0] + f[1] + f[2] + f[3]);
}

vec3 GlobalClipPosToWorldPos(vec4 clipPos)
{
    vec4 worldPos = globalUBO.invView * globalUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

//vec3 GlobalClipDirToWorldDir(vec3 direction)
//{
////        mat4 invViewProj = inverse(globalUBO.proj * globalUBO.view);
////        vec4 worldDir = invViewProj * vec4(direction, 0);
////        return worldDir.xyz / worldDir.w; // w divide needed????
//    return (globalUBO.invView * globalUBO.invProj * vec4(direction, 0)).xyz;
//}

vec4 GlobalClipPosFromWorldPos(vec3 worldPos)
{
    return globalUBO.proj * globalUBO.view * vec4(worldPos, 1);
}

vec3 NodeClipPosToWorldPos(vec4 clipPos)
{
    vec4 worldPos = nodeUBO.invView * nodeUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

//vec3 NodeClipDirToWorldDir(vec3 direction)
//{
//        mat4 invViewProj = inverse(nodeUBO.proj * nodeUBO.view);
//        vec4 worldDir = invViewProj * vec4(direction, 0);
//        return worldDir.xyz / worldDir.w; // w divide needed????
////    return (nodeUBO.invView * nodeUBO.invProj * vec4(direction, 0)).xyz;
//}

vec4 NodeClipPosFromWorldPos(vec3 worldPos)
{
    return nodeUBO.proj * nodeUBO.view * vec4(worldPos, 1);
}

vec3 NDCFromClipPos(vec4 clipPos)
{
    return clipPos.xyz / clipPos.w;
}

vec2 UVToNDC(vec2 uv)
{
    return vec2(vec2(1, -1) * (uv * 2 - 1));;
}

vec2 UVFromNDC(vec3 ndc)
{
    return (vec2((vec2(1, -1) * ndc.xy) + 1) * 0.5);
}

ivec2 CoordFromUV(vec2 uv, vec2 screenSize)
{
    return ivec2(round(uv * screenSize));
}

vec2 CoordToUV(ivec2 coord, vec2 screenSize)
{
    return vec2(coord) / screenSize;
}

void Reproject(ivec2 coord, ivec2 offset)
{

    //    const ivec2 revCoord = ivec2(globalUBO.width - coord.x, coord.y);// honestly dont quite understand why this revcoord is needed compared to mesh shader
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);
    const vec2 uv = CoordToUV(coord, screenSize);
    const vec2 ndc = UVToNDC(uv);
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldRayPos = GlobalClipPosToWorldPos(clipPos);

    const vec4 clipRayDir = vec4(ndc, 1, 1);
    const vec4 viewSpace = globalUBO.invProj * clipRayDir;
    const vec4 viewDir = vec4(viewSpace.xy, 1, 0);
    const vec3 globalWorldRayDir = normalize((globalUBO.invView * viewDir).xyz);

    const vec3 nodeOriginWorldPos = vec3(0, 0, 0);
    const vec3 nodeOriginWorldDirection = vec3(0, 0, 1);// -1 face towards view
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldRayPos, globalWorldRayDir, nodeOriginWorldPos, nodeOriginWorldDirection);

    vec4 testRayClipPos = GlobalClipPosFromWorldPos(intersectWorldPos);
    vec3 testRayNDC = NDCFromClipPos(testRayClipPos);
    vec2 testRayUV = UVFromNDC(testRayNDC);
    ivec2 testRayCoord = CoordFromUV(testRayUV, screenSize);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);
//    const ivec2 nodeIntersectCoord = CoordFromUV(nodeIntersectUV, screenSize);

    const vec4 color = texture(nodeColor, nodeIntersectUV);
    const float depth = texture(nodeDepth, nodeIntersectUV).r;

    const vec3 colorSRGB = pow(color.rgb, vec3(1.0 / 2.2));

    const vec4 nodeQuadClipPos = vec4(nodeIntersectNDC.xy, color.z > 0 ? depth : nodeIntersectNDC.z, 1);
    const vec3 nodeQuadWorldPos = NodeClipPosToWorldPos(nodeQuadClipPos);

    const vec4 newClipPos = GlobalClipPosFromWorldPos(nodeQuadWorldPos);
    const vec3 newNDC = NDCFromClipPos(newClipPos);
    const vec2 newUV = UVFromNDC(newNDC);
    const ivec2 newCoord = CoordFromUV(newUV, screenSize);

    imageStore(outputColor, newCoord, vec4(colorSRGB, 1));
}

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    Reproject(coord, ivec2(0, 0));
    //    Reproject(coord, ivec2(1, 1));

    //    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    //    const ivec2 revCoord = ivec2(globalUBO.width - coord.x, coord.y);// honestly dont quite understand why this revcoord is needed compared to mesh shader
    //    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    //    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height);
    //    const vec2 uv = vec2(revCoord) / screenSize;
    //    const vec2 ndc = UVToNDC(uv);
    //
    //    const mat4 nodeProjView = nodeUBO.proj * nodeUBO.view;
    //    const vec4 nodeOriginClipPos = nodeProjView * vec4(0, 0, 0, 1);
    //    const vec4 nodeDirection = nodeProjView * vec4(0, 0, -1, 0);// -1 face towards view
    //    const vec3 intersectWorldPos = intersectRayPlane(vec3(ndc, 0), vec3(0, 0, 1), nodeOriginClipPos.xyz, nodeDirection.xyz);
    //    const vec4 intersectClipPos = nodeProjView * vec4(intersectWorldPos, 1);
    //    const vec3 intersectNDC = ClipPosToNDC(intersectClipPos);
    //    const vec2 intersectUV = NDCToUV(intersectNDC);
    //
    //    const vec4 color = texture(nodeColor, intersectUV);
    //    const float depth = texture(nodeDepth, intersectUV).r;
    //
    //    const vec3 colorSRGB = pow(color.rgb, vec3(1.0 / 2.2));
    //
    //    const vec4 nodeQuadClipPos = vec4(intersectNDC.xy, 0, 1);
    //    const vec4 nodeQuadWorldPos = toNodeWorldPos(nodeQuadClipPos);
    //
    //    const vec4 newClipPos = globalUBO.proj * globalUBO.view * nodeQuadWorldPos;
    //    const vec3 newNDC = newClipPos.xyz / newClipPos.w;
    //    const vec2 newUV = NDCToUV(newNDC);
    //
    //    const ivec2 newCoord = ivec2(round(newUV * screenSize));
    //
    //    const ivec2 finalCoord = color.a > 0 ?  newCoord : ivec2(-1, -1);
    //    imageStore(outputColor, finalCoord, vec4(colorSRGB, 1));


    //    int dx = newCoord.x - coord.x;
    //    int dy = newCoord.y - coord.y;
    //    int absDX = abs(dx);
    //    int absDY = abs(dy);
    //    bool shouldStepX = absDX > absDY;
    //    int xDirection = dx > 0 ? 1 : -1;
    //    int yDirection = dy > 0 ? 1 : -1;
    //    float stepAngle = shouldStepX ? float(dy) / float(absDX) : float(dx) / float(absDY);
    //    ivec2 stepCoord = newCoord;
    //    for (int i = 0; i < 4; ++i){
    //        stepCoord.x = shouldStepX ? i * xDirection : int(round(float(i) * stepAngle));
    //        stepCoord.y = shouldStepX ? int(round(float(i) * stepAngle)) : i * yDirection ;
    //        const ivec2 finalStepCoord = color.a > 0 ?  stepCoord : ivec2(-1, -1);
    //        imageStore(outputColor, finalStepCoord, vec4(colorSRGB, 1));
    //    }

    //    imageStore(outputColor, newCoord + ivec2(0, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(1, 1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(-1, 1), color);
    //    imageStore(outputColor, newCoord + ivec2(1, -1), color);
    //
    //    imageStore(outputColor, newCoord + ivec2(0, -1), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, 0), color);
    //    imageStore(outputColor, newCoord + ivec2(-1, -1), color);
}
