#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

#define MXC_CAMERA_MIN_Z 0.0001f

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (set = 1, binding = 6, r32ui) uniform uimage2D outputAtomic;

vec3 nodeOriginWorldPos = vec3(0, 0, -0.5);
const vec3 nodeOriginWorldDirection = vec3(0, 0, 1);

vec3 intersectRayPlane(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal) {
    const float facingRatio = dot(planeNormal, rayDir);
    const float t = dot(planePoint - rayOrigin, planeNormal) / facingRatio;
    return (facingRatio < 0) ? (rayOrigin + t * rayDir) : vec3(0, 0, 0);
}

vec3 WorldPosFromGlobalClipPos(vec4 clipPos)
{
    const vec4 worldPos = globalUBO.invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec3 NDCRay(vec2 ndc, mat4 invProj, mat4 invView)
{
    const vec4 clipRayDir = vec4(ndc, 0, 1);
    const vec4 viewSpace = invProj * clipRayDir;
    const vec4 viewDir = vec4(viewSpace.xy, 1, 0);
    const vec3 globalWorldRayDir = normalize((invView * viewDir).xyz);
    return globalWorldRayDir;
}

vec3 GlobalNDCRay(vec2 ndc)
{
    return NDCRay(ndc, globalUBO.invProj, globalUBO.invView);
}

vec3 NodeNDCRay(vec2 ndc)
{
    return NDCRay(ndc, nodeUBO.invProj, nodeUBO.invView);
}

vec4 GlobalClipPosFromWorldPos(vec3 worldPos)
{
    return globalUBO.viewProj * vec4(worldPos, 1);
}

vec3 WorldPosFromNodeClipPos(vec4 clipPos)
{
    const vec4 worldPos = nodeUBO.invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec4 NodeClipPosFromWorldPos(vec3 worldPos)
{
    return nodeUBO.viewProj * vec4(worldPos, 1);
}

vec3 NDCFromClipPos(vec4 clipPos)
{
    return clipPos.xyz / clipPos.w;
}

vec2 NDCFromUV(vec2 uv)
{
    return uv * 2.0 - 1.0;
}

vec2 UVFromNDC(vec3 ndc)
{
    return (ndc.xy + 1.0) * 0.5;
}

ivec2 iRound(vec2 coord)
{
    return ivec2(round(coord));
}

ivec2 CoordFromUV(vec2 uv, vec2 screenSize)
{
    return iRound(uv * screenSize);
}

vec2 uvFromCoord(ivec2 coord, vec2 screenSize)
{
    return vec2(coord) / screenSize;
}

float unlinearizeDepth(float d, mat4 projMatrix) {
    float a = projMatrix[2][2];
    float b = projMatrix[3][2];
    return (a * d + b) / d;
}

float linearizeDepth(float z, mat4 projMatrix) {
    float a = projMatrix[2][2];
    float b = projMatrix[3][2];
    return b / (z - a);
}

float linearizeDepth(float d, float zNear, float zFar)
{
    return zNear * zFar / (zFar + d * (zNear - zFar));
}

float unlinearizeDepth(float d, float near, float far) {
    return (far + near - (2.0 * near * far) / d) / (far - near);
}

float calculateNonLinearDepth(float d_mid, mat4 projMatrix) {
    float n = projMatrix[3][2] / (projMatrix[2][2] - 1.0);
    float f = projMatrix[3][2] / (projMatrix[2][2] + 1.0);

    float z_clip = (-f * n * (2.0 * d_mid)) / (d_mid * (f + n)) - (f + n) / (f - n);
    float z_ndc = (z_clip + 1.0) / 2.0;// Adjusting from [-1, 1] to [0, 1] for Vulkan NDC

    return z_ndc;
}

float calculateWForMidpoint(float near, float far) {
    float d_mid = (near + far) / 2.0f;
    float w = 2.0f * ((far + near) * d_mid - 2.0f * far * near) / (0.5f * (far - near));
    return w;
}

bool NodeIntersectUV(const vec2 uv, out vec2 nodeUV, out vec3 stepNormalNDC, out vec3 depthProjectedNDC)
{
    // for whatever reason sending uv through the whole projection math and back
    // ends you up with the uv inverted so do 1 - uv here so outuv lines up with start uv
    const vec2 ndc = NDCFromUV(1 - uv);

    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);
    nodeUV = nodeIntersectUV;

    const vec3 nodeWorldNormal = texture(nodeNormalTexture, nodeIntersectUV).xyz * vec3(1.0, -1.0, 1.0);
    const float depth = texture(nodeDepthTexture, nodeIntersectUV).r;

    if (nodeIntersectUV.x < 0
    || nodeIntersectUV.x > 1
    || nodeIntersectUV.y < 0
    || nodeIntersectUV.y > 1
    || depth > .99
    || dot(nodeWorldNormal.xyz, globalWorldRay) < 0
    ) {
        return false;
    }

    const vec4 nodeQuadDepthClipPos = vec4(nodeIntersectNDC.xy, depth, 1);
    const vec3 nodeQuadDepthWorldPos = WorldPosFromNodeClipPos(nodeQuadDepthClipPos);
    const vec4 nodeQuadDepthProjectedClipPos = GlobalClipPosFromWorldPos(nodeQuadDepthWorldPos);
    const vec3 nodeQuadDepthProjectedNDC = NDCFromClipPos(nodeQuadDepthProjectedClipPos);
    depthProjectedNDC = nodeQuadDepthProjectedNDC;

    const vec3 stepNormalWorldPos = nodeQuadDepthWorldPos + (nodeWorldNormal * 0.1);
    const vec4 stepNormalClipPos = GlobalClipPosFromWorldPos(stepNormalWorldPos);
    stepNormalNDC = NDCFromClipPos(stepNormalClipPos);

    return true;
}

void writeAtomicData(ivec2 coord, uint data){
    imageAtomicMin(outputAtomic, coord, data);
}

uint packFloatAndColor(float normalizedDepth, vec3 color) {
    uint packedValue = uint(normalizedDepth * 65535.0);

    uint r = uint(color.r * 31.0);
    uint g = uint(color.g * 63.0);
    uint b = uint(color.b * 31.0);
    uint packedColor = (r << 11) | (g << 5) | b;

    return (packedValue << 16) | packedColor;
}

void WriteDebugUV(vec2 debugUV){
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screenSize = vec2(globalUBO.width, globalUBO.height) * RESOLUTION_SCALE;
    const ivec2 debugCoord = CoordFromUV(debugUV, screenSize);
    const ivec2 diff = coord - debugCoord;
    if (dot(diff, diff) < 100){
        const uint packedData = packFloatAndColor(0, vec3(0, 1, 0));
        writeAtomicData(coord, packedData);
    }
}

float inverseLerp(float value, float a, float b) {
    return a == b ? 0 : (value - a) / (b - a);
}

vec3 GlobalNDCFromNodeNDC(vec3 nodeNDC){
    const vec3 worldPos = WorldPosFromNodeClipPos(vec4(nodeNDC, 1));
    const vec4 globalClipPos = GlobalClipPosFromWorldPos(worldPos.xyz);
    const vec3 globalNDC = NDCFromClipPos(globalClipPos);
    return globalNDC;
}

float areaOfQuadrilateral(vec2 a, vec2 b, vec2 c, vec2 d) {
    return 0.5 * abs(
    a.x * b.y + b.x * c.y + c.x * d.y + d.x * a.y -
    (b.x * a.y + c.x * b.y + d.x * c.y + a.x * d.y)
    );
}

float areaOfQuadrilateral(vec2 verts[4]) {
    return areaOfQuadrilateral(verts[0], verts[1], verts[2], verts[3]);
}

float SqrMag(vec2 values[2]) {
    const  vec2 diff = values[0] - values[1];
    return dot(diff, diff);
}

const int ndcCornerCount = 2;
const vec2 ndcCorners[] = {
{ -1, 1 },
{ 1, -1 },
};

float CalcNodeZPlane(){

    vec2 uvs[ndcCornerCount];
    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 0));
        if (ndc.z < 0) {
            return 1;// maybe -z?
        }
        uvs[i] = UVFromNDC(ndc);
    }
    const float frontMag = SqrMag(uvs);

    for (int i = 0; i < ndcCornerCount; ++i){
        const vec3 ndc = GlobalNDCFromNodeNDC(vec3(ndcCorners[i].xy, 1));
        uvs[i] = UVFromNDC(ndc);
    }
    const float backMag = SqrMag(uvs);

    float nodeZPlane = frontMag < backMag ? 1 : -1;
    if (abs(frontMag - backMag) < .1) {
        nodeZPlane = -1;
    }

    return nodeZPlane;
}

void XYCoordNormalizedDir(const vec2 dir, out bool isXDir, out vec2 normalizedDir){
    const vec2 absDir = abs(dir);
    isXDir = absDir.x > absDir.y;
    const vec2 xNormalizedDir = dir * (1.0f / absDir.x);
    const vec2 yNormalizedDir = dir * (1.0f / absDir.y);
    normalizedDir = (isXDir ? xNormalizedDir : yNormalizedDir);
}

void main()
{
//    nodeOriginWorldPos.z = CalcNodeZPlane() * 0.5;
    nodeOriginWorldPos.z = nodeUBO.planeZDepth;

//    WriteDebugUV(vec2(0.5, nodeOriginWorldPos.z + .5));

    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height) * RESOLUTION_SCALE;
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = uvFromCoord(coord, screenSize);

    // calc source pixel
    vec2 nodeUV;
    vec3 stepNormalNDC;
    vec3 depthProjectedNDC;
    if (!NodeIntersectUV(uv, nodeUV, stepNormalNDC, depthProjectedNDC)) {
        return;
    }

    // write source pixel
    const vec2 depthProjectUV = UVFromNDC(depthProjectedNDC);
    const vec4 color = texture(nodeColorTexture, nodeUV);
    const uint packedData = packFloatAndColor(depthProjectedNDC.z, color.xyz);
    const ivec2 depthProjectedCoord = CoordFromUV(depthProjectUV, screenSize);
    writeAtomicData(depthProjectedCoord, packedData);


    // calc and write step normal pixel
//    const vec2 stepNormalUV = UVFromNDC(stepNormalNDC);
//    const vec2 stepNormalDir = stepNormalUV - uv;
////    const ivec2 stepNormalCoord = CoordFromUV(stepNormalUV, screenSize);
//    vec2 normalizedStepNormalDir;
//    bool stepNormalDirIsX;
//    XYCoordNormalizedDir(stepNormalDir, stepNormalDirIsX, normalizedStepNormalDir);
//    const ivec2 stepNormalCoord = iRound(normalizedStepNormalDir + vec2(depthProjectedCoord));
//    writeAtomicData(stepNormalCoord, packedData);
//    const ivec2 stepNormalCoord2 = iRound(2.0 * normalizedStepNormalDir + vec2(depthProjectedCoord));
//    writeAtomicData(stepNormalCoord2, packedData);

    // calc stepback
//    const vec2 stepBackDir = depthProjectUV - uv;
//    vec2 normalizedStepBackDir;
//    bool stepBackDirIsX;
//    XYCoordNormalizedDir(stepBackDir, stepBackDirIsX, normalizedStepBackDir);
//    const ivec2 stepBackCoord = iRound(normalizedStepBackDir + vec2(coord));
//    const vec2 stepBackUV = uvFromCoord(stepBackCoord, screenSize);
//    vec2 stepBackNodeUV;
//    vec3 stepBackStepNormalNDC;
//    vec3 stepBackProjectedNDC;
//    if (!NodeIntersectUV(stepBackUV, stepBackNodeUV, stepBackStepNormalNDC, stepBackProjectedNDC)) {
//        return;
//    }

    // write stepback pixels
//    const vec2 stepbackProjectedUV = UVFromNDC(stepBackProjectedNDC);
//    const ivec2 stepbackOutputUVCoord = CoordFromUV(stepbackProjectedUV, screenSize);
//    const ivec2 stepBackCoordDiff = abs(stepbackOutputUVCoord - depthProjectedCoord);
//    const int stepbackCount = clamp((stepBackDirIsX ? stepBackCoordDiff.x : stepBackCoordDiff.y) - 1, 0, 4);// -1 so it doesn't overlap end pixel in stepback
//    vec2 currentCoord = depthProjectedCoord;
//    ivec2 roundedCoord = depthProjectedCoord;
//    for (int step = 0; step < stepbackCount; ++step){
//        currentCoord += normalizedStepBackDir;
//        roundedCoord = iRound(currentCoord);
//        writeAtomicData(roundedCoord, packedData);
//    }
}
