#version 450

#include "global_binding.glsl"
#include "compute_node_binding.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

// varying this .5 is probably solution to sperating pixels
// puling it closer makes less separation up close, probably a ratio to figure out
const vec3 nodeOriginWorldPos = vec3(0, 0, -.5);
const vec3 nodeOriginWorldDirection = vec3(0, 0, 1);

const int offsetCount = 4;
const ivec2 coordOffsets[offsetCount] = {
{ 0, 0 },
{ 1, 0 },
{ 1, 1 },
{ 0, 1 }
};

const int writeOffsetcount = 8;
const ivec2 writeOffsets[writeOffsetcount] = {
{ -1, 1 },
{ 0, 1 },
{ 1, 1 },
{ 1, 0 },
{ 1, -1 },
{ 0, -1 },
{ -1, -1 },
{ -1, 0 }
};

vec3 intersectRayPlane(vec3 rayOrigin, vec3 rayDir, vec3 planePoint, vec3 planeNormal) {
    const float facingRatio = dot(planeNormal, rayDir);
    const float t = dot(planePoint - rayOrigin, planeNormal) / facingRatio;
    return (facingRatio < 0) ? (rayOrigin + t * rayDir) : vec3(0, 0, 0);
}

vec3 WorldPosFromGlobalClipPos(vec4 clipPos)
{
    const vec4 worldPos = globalUBO.invView * globalUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec3 GlobalNDCRay(vec2 ndc)
{
    const vec4 clipRayDir = vec4(ndc, 0, 1);
    const vec4 viewSpace = globalUBO.invProj * clipRayDir;
    const vec4 viewDir = vec4(viewSpace.xy, 1, 0);
    const vec3 globalWorldRayDir = normalize((globalUBO.invView * viewDir).xyz);
    return globalWorldRayDir;
}

vec4 GlobalClipPosFromWorldPos(vec3 worldPos)
{
    return globalUBO.proj * globalUBO.view * vec4(worldPos, 1);
}

vec3 WorldPosFromNodeClipPos(vec4 clipPos)
{
    const vec4 worldPos = nodeUBO.invView * nodeUBO.invProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

vec4 NodeClipPosFromWorldPos(vec3 worldPos)
{
    return nodeUBO.proj * nodeUBO.view * vec4(worldPos, 1);
}

vec3 NDCFromClipPos(vec4 clipPos)
{
    return clipPos.xyz / clipPos.w;
}

vec2 NDCFromUV(vec2 uv)
{
    return uv * 2.0 - 1.0;
}

vec2 UVFromNDC(vec3 ndc)
{
    return (ndc.xy + 1.0) * 0.5;
}

ivec2 CoordFromUV(vec2 uv, vec2 screenSize)
{
    return ivec2(round(uv * screenSize));
}

vec2 uvFromCoord(ivec2 coord, vec2 screenSize)
{
    return vec2(coord) / screenSize;
}

bool NodeIntersectUV(const vec2 uv, out vec2 nodeUV, out vec2 outputUv)
{
    // for whatever reason sending uv through the whole projection math and back
    // ends you up with the uv inverted so do 1 - uv here so outuv lines up with start uv
    const vec2 ndc = NDCFromUV(1 - uv);
    const vec4 clipPos = vec4(ndc, 0, 1);
    const vec3 globalWorldPos = WorldPosFromGlobalClipPos(clipPos);
    const vec3 globalWorldRay = GlobalNDCRay(ndc);
    const vec3 intersectWorldPos = intersectRayPlane(globalWorldPos, globalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);

    const vec4 nodeIntersectClipPos = NodeClipPosFromWorldPos(intersectWorldPos);
    const vec3 nodeIntersectNDC = NDCFromClipPos(nodeIntersectClipPos);
    const vec2 nodeIntersectUV = UVFromNDC(nodeIntersectNDC);
    nodeUV = nodeIntersectUV;

    const float depth = texture(nodeDepth, nodeIntersectUV).r;

    if (nodeIntersectUV.x < 0 || nodeIntersectUV.x > 1 || nodeIntersectUV.y < 0 || nodeIntersectUV.y > 1 || depth > .99) {
        return false;
    }

    const vec4 nodeQuadDepthClipPos = vec4(nodeIntersectNDC.xy, depth, 1);
    const vec3 nodeQuadDepthWorldPos = WorldPosFromNodeClipPos(nodeQuadDepthClipPos);
    const vec4 nodeQuadDepthProjectedClipPos = GlobalClipPosFromWorldPos(nodeQuadDepthWorldPos);
    const vec3 nodeQuadDepthProjectedNDC = NDCFromClipPos(nodeQuadDepthProjectedClipPos);
    const vec2 nodeQuadDepthProjectedUV = UVFromNDC(nodeQuadDepthProjectedNDC);
    outputUv = nodeQuadDepthProjectedUV;

    return true;
}

void writeColor(const vec2 nodeUV, const ivec2 outputCoord){
    const vec4 color = texture(nodeColor, nodeUV);
    const vec3 colorSRGB = pow(color.rgb, vec3(1.0 / 2.2));
    imageStore(outputColor, outputCoord, vec4(colorSRGB, color.a));
}

void main()
{
    const ivec2 iScreenSize = ivec2(globalUBO.width, globalUBO.height);
    const vec2 screenSize = vec2(iScreenSize);
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = uvFromCoord(coord, screenSize);

    vec2 nodeUV, projectedUV;
    if (!NodeIntersectUV(uv, nodeUV, projectedUV)) {
        return;
    }

    const ivec2 outputDepthCoord = CoordFromUV(projectedUV, screenSize);

    const vec4 color = texture(nodeColor, nodeUV);
    const vec4 colorSRGB = vec4(pow(color.rgb, vec3(1.0 / 2.2)), color.a);
    imageStore(outputColor, outputDepthCoord, colorSRGB);

    const vec2 projectionDir = projectedUV - uv;
    const vec2 absProjectionDir = abs(projectionDir);
    const bool walkX = absProjectionDir.x > absProjectionDir.y;
    const vec2 xNormalizedProjectionDir = projectionDir * (1.0f / absProjectionDir.x);
    const vec2 yNormalizedProjectionDir = projectionDir * (1.0f / absProjectionDir.y);
    const vec2 normalizedProjectionDir = (walkX ? xNormalizedProjectionDir : yNormalizedProjectionDir);

    // We must do the stepback in coord space to ensure it only goes back 1 pixel
    // can this be merged with the other NodeIntersetUV method?
    const ivec2 stepbackCoord = ivec2(round(normalizedProjectionDir + vec2(coord)));
    const vec2 stepbackUV = uvFromCoord(stepbackCoord, screenSize);

    vec2 stepbackNodeUV, stepbackProjectedUV;
    if (!NodeIntersectUV(stepbackUV, stepbackNodeUV, stepbackProjectedUV)) {
        return;
    }

    const ivec2 stepbackOutputUVCoord = CoordFromUV(stepbackProjectedUV, screenSize);
    const ivec2 stepbackCoordDiff = abs(stepbackOutputUVCoord - outputDepthCoord);
    const int sepbackCount = walkX ? stepbackCoordDiff.x : stepbackCoordDiff.y;
    vec2 currentCoord = outputDepthCoord;
    ivec2 roundedCoord = outputDepthCoord;
    for (int step = 0; step < sepbackCount; ++step) {
        currentCoord += normalizedProjectionDir;
        roundedCoord = ivec2(round(currentCoord));
        imageStore(outputColor, roundedCoord, colorSRGB);
    }


//    const vec2 stepbackNDC = NDCFromUV(stepbackUV);
//    const vec4 stepbackClipPos = vec4(stepbackNDC, 0, 1);
//    const vec3 stepBackSurfaceGlobalWorldPos = WorldPosFromGlobalClipPos(stepbackClipPos);
//    const vec3 stepbackSurfaceGlobalWorldRay = GlobalNDCRay(stepbackNDC);
//    const vec3 stepBackSurfaceIntersectWorldPos = intersectRayPlane(stepBackSurfaceGlobalWorldPos, stepbackSurfaceGlobalWorldRay, nodeOriginWorldPos, nodeOriginWorldDirection);
//    const vec4 stepBackSurfaceNodeIntersectClipPos = NodeClipPosFromWorldPos(stepBackSurfaceIntersectWorldPos);
//    const vec3 stepBackSurfaceNodeIntersectNDC = NDCFromClipPos(stepBackSurfaceNodeIntersectClipPos);
//    const vec2 stepBackSurfaceNodeIntersectUV = UVFromNDC(stepBackSurfaceNodeIntersectNDC);
//    //    const ivec2 stepBackSurfaceNodeIntersectCoord = CoordFromUV(stepBackSurfaceNodeIntersectUV, screenSize);
//    const float stepBackSurfaceDepth = texture(nodeDepth, stepBackSurfaceNodeIntersectUV).r;
//    imageStore(outputColor, stepbackCoord, colorSRGB);
//    imageStore(outputColor, coord, colorSRGB);
//
//    const vec4 stepBackSurfaceDepthClipPos = vec4(stepBackSurfaceNodeIntersectNDC.xy, stepBackSurfaceDepth, 1);
//    const vec3 stepBackSurfaceDepthWorldPos = WorldPosFromNodeClipPos(stepBackSurfaceDepthClipPos);
//    const vec4 stepBackSurfaceDepthProjectedClipPos = GlobalClipPosFromWorldPos(stepBackSurfaceDepthWorldPos);
//    const vec3 stepBackSurfaceDepthProjectedNDC = NDCFromClipPos(stepBackSurfaceDepthProjectedClipPos);
//    const vec2 stepBackSurfaceDepthProjectedUV = UVFromNDC(stepBackSurfaceDepthProjectedNDC);
//    const ivec2 stepBackSurfaceDepthProjectedCoord = CoordFromUV(stepBackSurfaceDepthProjectedUV, screenSize);
    //    imageStore(outputColor, stepBackSurfaceDepthProjectedCoord, colorSRGB);


    //    vec2 coordDiff = stepBackSurfaceDepthProjectedCoord - outputDepthCoord;

    //    int stepbackCount = 10;
    //    if (stepbackCount > 10)
    //    stepbackCount = 10;
    //    for (int i = 1; i < 10; ++i) {
    //        const ivec2 stepBackCoord = ivec2(round(float(i) * (walkX ? xNormalizedProjectionDir : yNormalizedProjectionDir) + vec2(outputDepthCoord)));
    //        imageStore(outputColor, stepBackCoord, colorSRGB);
    //    }


    //    vec2 nodeUVs[offsetCount];
    //    vec2 outputUVs[offsetCount];
    //    ivec2 outputCoords[offsetCount];
    //    for (int i = 0; i < offsetCount; ++i){
    //        const vec2 uv = CoordToUV(coord + coordOffsets[i], screenSize);
    //        if (!NodeIntersetUV(uv, nodeUVs[i], outputUVs[i]))
    //            return;
    //        outputCoords[i] = CoordFromUV(outputUVs[i], screenSize);
    //    }

    //    const vec4 color = texture(nodeColor, nodeUVs[0]);
    //    const vec4 colorSRGB = vec4(pow(color.rgb, vec3(1.0 / 2.2)), color.a);
    //    imageStore(outputColor, outputCoords[0], colorSRGB);

    //    writeColor(nodeUVs[0], outputCoords[0]);

    //    for (int i = 0; i < writeOffsetcount; ++i){
    //        imageStore(outputColor, outputCoords[0] + writeOffsets[i], colorSRGB);
    //    }

}
