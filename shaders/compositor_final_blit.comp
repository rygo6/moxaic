#version 450

#include "global_binding.glsl"
#include "math.glsl"
#include "subgroup_grid.glsl"
#include "logging.glsl"

#define BIND_ARRAY_INDEX_FINAL_BLIT_SRC_GRAPHICS_FRAMEBUFFER 0
#define BIND_ARRAY_INDEX_FINAL_BLIT_SRC_COMPUTE_FRAMEBUFFER 1

layout (local_size_x = SUBGROUP_COUNT, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

layout (set = 1, binding = 0, rgba8) uniform readonly image2D src[];
layout (set = 1, binding = 1, rgba8) uniform writeonly image2D dst;

#define STEPS 32
#define DIST 0.01

vec3 WorldRayDirFromNDC(vec2 ndc, mat4 invProj, mat4 invView)
{
    vec4 clipRayDir = vec4(ndc, 0, 1);
    // this is actrually onl faster than WorldRayDirFromNDC2 if somehow we can do one mult with invViewProj
    vec4 viewSpace = invProj * clipRayDir;
    vec4 viewDir = vec4(viewSpace.xy, -1, 0); // we look down -1 z in view space for vulkan?
    vec3 worldRayDir = normalize((invView * viewDir).xyz);
    return worldRayDir;
}

vec3 WorldRayDirFromNDC2(vec2 ndc, mat4 invViewProj)
{
    vec4 clipNear = vec4(ndc, 1, 1);
    vec4 clipFar = vec4(ndc, 0, 1);

    vec4 worldPosNear = invViewProj * clipNear;
    worldPosNear.xyz /= worldPosNear.w;

    vec4 worldPosFar = invViewProj * clipFar;
    worldPosFar.xyz /= worldPosFar.w;

    vec3 nearToFarRay = worldPosFar.xyz - worldPosNear.xyz;
    return normalize(nearToFarRay);
}

float DDATrace(vec3 rayOrigin, vec3 rayDirNormalized) {

    vec3 rayDirInv = 1.0f / rayDirNormalized;
    vec3 rayDirSign = sign(rayDirNormalized);

    vec3 deltaDist = abs(rayDirInv);
    ivec3 deltaVoxel = ivec3(rayDirSign);

    vec3 fractPart = rayOrigin - floor(rayOrigin);
    vec3 sideDist = (rayDirSign * (0.5 - fractPart) + 0.5) * deltaDist;

    ivec3 voxel = ivec3(floor(rayOrigin));
    float color = 0;

    const float maxDistance = 16;
    const int MAX_ITERATIONS = 32;
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
        voxel += ivec3(mask) * deltaVoxel;

        vec3 hit = voxel + vec3(lessThan(deltaVoxel, ivec3(0.0)));
        vec3 hitRay = hit - rayOrigin;
        float hitRayDistance = length(hitRay);
        float hitRayDistanceNormalized = hitRayDistance / maxDistance;

        vec3 hitRayNormalized = (hitRay / rayDirNormalized);
        float t = mask.x ? hitRayNormalized.x : mask.y ? hitRayNormalized.y : mask.z ? hitRayNormalized.z : 0;

        vec3 hitPos = rayOrigin + rayDirNormalized * t;
        vec3 localPos = hitPos - voxel;
        vec2 local2DPos = mask.x ? localPos.yz : mask.y ? localPos.xz : mask.z ? localPos.xy : vec2(0.5);
        vec2 local2DPosCenter = abs(local2DPos - 0.5) * 2.0;
        float local2DPosCenterBoxDistance = max(local2DPosCenter.x, local2DPosCenter.y);
        float local2DPosCenterCircleDistance = length(local2DPosCenter);
        float local2DPosCenterCornerDistance = 1.0 - length(1.0 - local2DPosCenter);

        // we need som more clamping and work here
        float threshold = 0.002 * hitRayDistance;
        float edge = smoothstep(1.0 - threshold, 1.0, local2DPosCenterBoxDistance);
        float cornerEdges = clamp(edge - (2.0 - local2DPosCenterCircleDistance * 1.0), 0.0, 1.0); // combine into one smoothstep
        float circles = smoothstep(.99 - threshold, .99, local2DPosCenterCornerDistance);
        float cornerEdgeCircles = cornerEdges + circles;

        color = max(color, cornerEdgeCircles * (1.0 - hitRayDistanceNormalized));
    }

    return color;
}

vec2 NDCFromUV(vec2 uv) { return uv * 2.0f - 1.0f; }

void main()
{
    ivec2 outputSize = imageSize(dst);
    InitializeSubgroupGridInfo(outputSize);

    vec2 ndc = NDCFromUV(grid_GlobalUV);
    vec3 camDir = WorldRayDirFromNDC(ndc,  globalUBO.invProj,  globalUBO.invView);
    vec3 camPos = (globalUBO.invView * vec4(0,0,0,1)).xyz;

    float result = DDATrace(camPos, camDir);
    vec4 traceColor = vec4(result,result,result,1.0);

    vec4 graphicsSample = imageLoad(src[BIND_ARRAY_INDEX_FINAL_BLIT_SRC_GRAPHICS_FRAMEBUFFER], grid_GlobalCoord);
    vec4 computeSample = imageLoad(src[BIND_ARRAY_INDEX_FINAL_BLIT_SRC_COMPUTE_FRAMEBUFFER], grid_GlobalCoord);
    vec4 finalColor = computeSample.a > 0 ? computeSample : graphicsSample.a > 0 ? graphicsSample : traceColor;
    imageStore(dst, grid_GlobalCoord, finalColor);
}

