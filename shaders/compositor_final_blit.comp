#version 450

#include "global_binding.glsl"
#include "math.glsl"
#include "subgroup_grid.glsl"
#include "logging.glsl"

#define BIND_ARRAY_INDEX_FINAL_BLIT_SRC_GRAPHICS_FRAMEBUFFER 0
#define BIND_ARRAY_INDEX_FINAL_BLIT_SRC_COMPUTE_FRAMEBUFFER 1

layout (local_size_x = SUBGROUP_COUNT, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

layout (set = 1, binding = 0, rgba8) uniform readonly image2D src[];
layout (set = 1, binding = 1, rgba8) uniform writeonly image2D dst;

#define STEPS 32
#define DIST 0.01

float trace(vec3 origin, vec3 dir) {
    float t = 0.0;
    int i;
    for (i = 0; i < STEPS; i++) {
        vec3 pos = origin + t * dir;
        float d = length(mod(pos, 1.0) - 0.5);
        if (d < DIST) break;
        t += d;
    }
    return 1.0 - float(i) / float(STEPS);
}

vec3 WorldRayDirFromNDC(vec2 ndc, mat4 invProj, mat4 invView)
{
    vec4 clipRayDir = vec4(ndc, 0, 1);
    // this is actrually onl faster than WorldRayDirFromNDC2 if somehow we can do one mult with invViewProj
    vec4 viewSpace = invProj * clipRayDir;
    vec4 viewDir = vec4(viewSpace.xy, -1, 0); // we look down -1 z in view space for vulkan?
    vec3 worldRayDir = normalize((invView * viewDir).xyz);
    return worldRayDir;
}

vec3 WorldRayDirFromNDC2(vec2 ndc, mat4 invViewProj)
{
    vec4 clipNear = vec4(ndc, 1, 1);
    vec4 clipFar = vec4(ndc, 0, 1);

    vec4 worldPosNear = invViewProj * clipNear;
    worldPosNear.xyz /= worldPosNear.w;

    vec4 worldPosFar = invViewProj * clipFar;
    worldPosFar.xyz /= worldPosFar.w;

    vec3 nearToFarRay = worldPosFar.xyz - worldPosNear.xyz;
    return normalize(nearToFarRay);
}

float unclampedLinearstep(float edge0, float edge1, float x) {
    return (x - edge0) / (edge1 - edge0);
}

float DDATrace(vec3 rayOrigin, vec3 rayDirNormalized) {

    vec3 rayDirInv = 1.0f / rayDirNormalized;
    vec3 rayDirSign = sign(rayDirNormalized);

    vec3 deltaDist = abs(rayDirInv);
    ivec3 deltaVoxel = ivec3(rayDirSign);

    vec3 fractPart = rayOrigin - floor(rayOrigin);
    vec3 sideDist = (rayDirSign * (0.5 - fractPart) + 0.5) * deltaDist;

    ivec3 voxel = ivec3(floor(rayOrigin));
    float color = 0;

    // Traversal loop with early termination
    const float maxDistance = 12;
    const int MAX_ITERATIONS = 16;
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
        voxel += ivec3(mask) * deltaVoxel;

        vec3 hit = voxel + vec3(lessThan(deltaVoxel, ivec3(0.0)));
        vec3 hitRay = hit - rayOrigin;
        float hitRayDistance = length(hitRay);
        float hitRayDistanceNormalized = hitRayDistance / maxDistance;

        vec3 hitRayNormalized = (hitRay / rayDirNormalized);
        float t = mask.x ? hitRayNormalized.x : mask.y ? hitRayNormalized.y : mask.z ? hitRayNormalized.z : 0;

        vec3 hitPos = rayOrigin + rayDirNormalized * t;
        vec3 localPos = hitPos - voxel;
        vec2 local2DPos = mask.x ? localPos.yz : mask.y ? localPos.xz : mask.z ? localPos.xy : vec2(0.5);
        float localLength = length(local2DPos);
        float threshold = Lerp(0.0002, 0.04, hitRayDistanceNormalized);
        vec4 accumulateColor = vec4(smoothstep(vec2(threshold), vec2(0.0), local2DPos), smoothstep(vec2(1.0 - threshold), vec2(1.0), local2DPos));

        color = max(color, dot(accumulateColor, vec4(1.0)) * (1.0 - hitRayDistanceNormalized));
    }

    return color;
}

vec2 NDCFromUV(vec2 uv)
{
    return uv * 2.0f - 1.0f;
}

void main()
{
    ivec2 outputSize = imageSize(dst);
    InitializeSubgroupGridInfo(outputSize);

    vec2 ndc = NDCFromUV(grid_GlobalUV);
    vec3 camDir = WorldRayDirFromNDC(ndc,  globalUBO.invProj,  globalUBO.invView);
//    vec3 camDir = WorldRayDirFromNDC2(ndc,  globalUBO.invViewProj);
    vec3 camPos = (globalUBO.invView * vec4(0,0,0,1)).xyz;

    float result = DDATrace(camPos, camDir);
    vec4 fragColor = vec4(result,result,result,result);


    vec4 graphicsSample = imageLoad(src[BIND_ARRAY_INDEX_FINAL_BLIT_SRC_GRAPHICS_FRAMEBUFFER], grid_GlobalCoord);
    vec4 computeSample = imageLoad(src[BIND_ARRAY_INDEX_FINAL_BLIT_SRC_COMPUTE_FRAMEBUFFER], grid_GlobalCoord);
    vec4 finalColor = computeSample.a > 0 ?
                        computeSample :
                        graphicsSample.a > 0 ?
                            graphicsSample :
                            fragColor;
    imageStore(dst, grid_GlobalCoord, fragColor);
}

