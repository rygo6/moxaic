#version 450
//#extension GL_EXT_debug_printf : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require

#include "global_binding.glsl"
#include "node_binding.glsl"

#include "common_util.glsl"
#include "math.glsl"
#include "subgroup_grid.glsl"

layout (local_size_x = SUBGROUP_CAPACITY, local_size_y = WORKGROUP_SUBGROUP_COUNT, local_size_z = 1) in;

layout (set = 2, binding = 0, r32ui) uniform uimage2D outputAtomic;
layout (set = 2, binding = 1, rgba8) uniform image2D outputColor;

const uint clearCurrentDepthFlagMask = 0x7FFFFFFFu;

uint PackDepth(bool current, float normalizedDepth) {
    normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);

    // Scale to use 31 bits (leaving the MSB for our flag)
    // Maximum value will be 2^31 - 1 = 2147483647
    uint packedValue = uint(normalizedDepth * 2147483647.0);

    // Set the MSB based on the flag (bit 31)
    packedValue = current ? packedValue | 0x80000000u : packedValue; // Set MSB to 1

    return packedValue;
}
void UnpackDepth(uint packedDepth, out float normalizedDepth, out bool current) {
    current = (packedDepth & 0x80000000u) != 0u;

    // Extract the value bits (clearing the flag bit)
    uint valueBits = packedDepth & 0x7FFFFFFFu;

    // Convert back to normalized float
    normalizedDepth = float(valueBits) / 2147483647.0;
}
bool UnpackDepthCurrentFlag(uint packedDepth) {
    return (packedDepth & 0x80000000u) != 0u;
}
uint SetDepthFlag(uint value) {
    return value | 0x80000000u;
}
uint ClearDepthFlag(uint value) {
    return value & 0x7FFFFFFFu;
}

void main()
{
    const ivec2 outputSize = imageSize(outputColor);
//    const ivec2 outputHalfSize = outputSize / 2;

    const uint globalWorkgroupIndex = gl_WorkGroupID.y;
    const ivec2 globalWorkgroupId = GlobalWorkgroupID(globalWorkgroupIndex, outputSize);

    const uint localSubgroupIndex = gl_GlobalInvocationID.y % WORKGROUP_SUBGROUP_COUNT;
    const ivec2 localWorkgroupID = LocalWorkgroupID(localSubgroupIndex);

    const uint globalSubgroupIndex = gl_GlobalInvocationID.y;
    const uint subgroupInvocIndex = gl_SubgroupInvocationID;
    const ivec2 subgroupID = SubgroupID(subgroupInvocIndex);

    const ivec2 globCoord = (subgroupID + localWorkgroupID + globalWorkgroupId);
//    const ivec2 globDoordQuad = (subgroupID + localWorkgroupID + globalWorkgroupId) * 2;

    const vec3 nodeOriginWorldPos = vec3(0, 0, 0);
    const vec3 nodeOriginWorldDirection = vec3(0, 0, -1);

    // Clear current flag, then determine what pixels to set to black
    ivec2 globCoords[4];
    bool currentFlags[4];
    int currentCount = 0;
//    for (int i = 0; i < 4; ++i) {
//        globCoords[i] = globDoordQuad + quadGatherOffsets[i];
        uint nodePackedDepth = imageAtomicAnd(outputAtomic, globCoord, clearCurrentDepthFlagMask);
//        currentFlags[i] = UnpackDepthCurrentFlag(nodePackedDepth);
//        currentCount += int(currentFlags[i]);
//    }

//    vec4 color = vec4(0);
//    if (currentCount > 1) {
//        for (int i = 0; i < 4; ++i) {
//            if (currentFlags[i]) {
//                color += imageLoad(outputColor, globCoords[i]);
//            }
//        }
//        color /= currentCount;
//    }
//
//    for (int i = 0; i < 4; ++i) {
//        if (!currentFlags[i]) imageStore(outputColor, globCoords[i], color);
//    }
}
