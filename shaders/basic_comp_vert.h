// This C++ shader is autogenerated by spirv-cross.
#include "spirv_cross/internal_interface.hpp"
#include "spirv_cross/external_interface.h"
#include <array>
#include <stdint.h>

using namespace spirv_cross;
using namespace glm;

namespace Impl
{
    struct Shader
    {
        struct Resources : VertexResources
        {
            struct GlobalUBO
            {
                mat4 view;
                mat4 proj;
                mat4 viewProj;
                mat4 invView;
                mat4 invProj;
                mat4 invViewProj;
                ivec2 screenSize;
            };
            
            internal::Resource<GlobalUBO> globalUBO__;
#define globalUBO __res->globalUBO__.get()
            
            struct NodeUBO
            {
                mat4 model;
                mat4 view;
                mat4 proj;
                mat4 viewProj;
                mat4 invView;
                mat4 invProj;
                mat4 invViewProj;
                ivec2 framebufferSize;
                vec2Value ulUV;
                vec2Value lrUV;
            };
            
            internal::Resource<NodeUBO> nodeUBO__;
#define nodeUBO __res->nodeUBO__.get()
            
            internal::StageInput<vec2Value> inUV__;
#define inUV __res->inUV__.get()
            
            internal::StageOutput<vec2Value> outUV__;
#define outUV __res->outUV__.get()
            
            internal::StageOutput<vec3Value> outNormal__;
#define outNormal __res->outNormal__.get()
            
            internal::StageInput<vec3Value> inNormal__;
#define inNormal __res->inNormal__.get()
            
            internal::StageInput<vec3Value> inPos__;
#define inPos __res->inPos__.get()
            
            internal::Resource<sampler2D> nodeColor__;
#define nodeColor __res->nodeColor__.get()
            
            internal::Resource<sampler2D> nodeGBuffer__;
#define nodeGBuffer __res->nodeGBuffer__.get()
            
            inline void init(spirv_cross_shader& s)
            {
                VertexResources::init(s);
                s.register_resource(globalUBO__, 0, 0);
                s.register_resource(nodeUBO__, 1, 0);
                s.register_stage_input(inUV__, 2);
                s.register_stage_output(outUV__, 1);
                s.register_stage_output(outNormal__, 0);
                s.register_stage_input(inNormal__, 1);
                s.register_stage_input(inPos__, 0);
                s.register_resource(nodeColor__, 1, 1);
                s.register_resource(nodeGBuffer__, 1, 2);
            }
        };
        
        Resources* __res;
        
        float doubleWide;
        bool clipped;
        bool cropped;
        
        inline void main()
        {
            vec4 _100 = (nodeUBO.viewProj * nodeUBO.model) * vec4(0.0f, 0.0f, 0.0f, 1.0f);
            vec2Value _133 = mix(nodeUBO.ulUV, nodeUBO.lrUV, inUV);
            outUV = _133;
            vec4 _196 = nodeUBO.invViewProj * vec4((_133 * 2.0f) - vec2Value(1.0f), _100.z / _100.w, 1.0f);
            gl_Position = globalUBO.viewProj * vec4(_196.xyz() / vec3Value(_196.w), 1.0f);
            outNormal = inNormal;
        }
        
    };
}

spirv_cross_shader_t *spirv_cross_construct(void)
{
    return new VertexShader<Impl::Shader, Impl::Shader::Resources>();
}

void spirv_cross_destruct(spirv_cross_shader_t *shader)
{
    delete static_cast<VertexShader<Impl::Shader, Impl::Shader::Resources>*>(shader);
}

void spirv_cross_invoke(spirv_cross_shader_t *shader)
{
    static_cast<VertexShader<Impl::Shader, Impl::Shader::Resources>*>(shader)->invoke();
}

static const struct spirv_cross_interface vtable =
{
    spirv_cross_construct,
    spirv_cross_destruct,
    spirv_cross_invoke,
};

const struct spirv_cross_interface *spirv_cross_get_interface(void)
{
    return &vtable;
}
